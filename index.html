<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Conversion Lat Long vers Merchich Maroc</title>
<meta name="description" content="Conversion des coordonnées Latitude Longitude vers Merchich Maroc (zones 1 à 4) et calcul de distance sur carte.">
<link rel="icon" href="convertgps.png" type="image/x-jpg">
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  .batch-toggle-btn {
    width: 100%;
    border: none;
    background-color: #198754;
    color: #fff;
    font-size: 1.25rem;
    font-weight: 600;
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }

  .batch-toggle-btn:hover,
  .batch-toggle-btn:focus {
    background-color: #157347;
  }

  .batch-toggle-btn:focus {
    outline: 0;
    box-shadow: 0 0 0 0.2rem rgba(25, 135, 84, 0.35);
  }

  .batch-toggle-icon {
    font-size: 1.5rem;
    line-height: 1;
    margin-inline-start: 1rem;
  }

  #batchSectionContent[hidden] {
    display: none;
  }
</style>
</head>
<body>
<div class="collapse" id="navbarToggleExternalContent">
  <div class="p-5 d-flex position-fixed ms-5" style="z-index: 1050; border-radius: 0 0.5rem 0.5rem 0;">
        <img src="convertgps.png" type="image/x-jpg" alt="" style="width: 2rem; margin: auto; display: flex;" >
        <a href="info.html" class="ms-5">معلومات مفيدة </a>
      </div>
    </div>
      <h4 class="text-white text-center my-3 rtl">X/Y و Lat/Long (D°M'S'') محول إحداثيات </h4>
    <nav class="navbar navbar-dark bg-success rounded position-fixed">
        <div class="container-fluid">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarToggleExternalContent" aria-controls="navbarToggleExternalContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        </div>
    </nav>
  </div>
<div class="container"  dir="rtl">
  <div class="conversion-header d-inline-flex">
    <div class="city-picker ">
      <label class="conversion-label" for="citySearchInput">اختر المدينة (اجباري)</label>
      <div class="city-select-block">
        <div class="city-search-wrapper">
          <input type="text" id="citySearchInput" class="form-control city-search-input d-inline-flex align-items-center gap-1 w-auto" placeholder="أدخل اسم المدينة..." autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-controls="citySuggestionsList">
          <button type="button" id="citySearchClearBtn" class="city-clear-btn" aria-label="مسح اسم المدينة" hidden>&times;</button>
          <div id="citySuggestionsList" class="city-suggestions" role="listbox" hidden></div>
        </div>
        <span class="city-zone-badge" id="cityZoneBadge" hidden aria-live="polite"></span>
      </div>
      <!--<p class="hint">يتم استخدام المدينة فقط لتأكيد نطاق المنطقة، وسيتم اختيار المنطقة الصحيحة تلقائيًا.</p>-->
    </div>

    <div class="conversion-type">
      <label class="conversion-label" for="conversionType">اختر نوع التحويل:</label>
      <select id="conversionType" class="form-select form-select-lg mb-3 d-inline-flex align-items-center gap-1 w-auto" aria-label="اختر نوع التحويل">
        <option value="Merchich-to-latlong" class="d-inline-flex align-items-center gap-1 w-auto">X/Y <span style='font-size:100px;'>&#8667;</span> Lat/Long (D°M'S'')</option>
        <option value="latlong-to-Merchich" class="d-inline-flex align-items-center gap-1 w-auto">Lat/Long (D°M'S'') <span style='font-size:100px;'>&#8667;</span> X/Y</option>
      </select>
    </div>
  </div>

  <div class="live-layout">
    <div class="manual-box">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <h4 class="manual-title">تحويل قيمة واحدة</h4>
        <button type="button" class="reload-btn" onclick="handleReload()" aria-label="إعادة تحميل الصفحة">
          <span aria-hidden="true">⟳</span>
        </button>
      </div>

      <p class="hint" id="manualHint"></p>
      <div class="manual-fields" id="dmsFields">
        <div class="dms-group">
          <label>خط العرض (شمال S/N جنوب):</label>
          <div class="dms-row">
            <input type="text" id="latDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="latHemisphere" class="hemisphere-select">
              <option value="N">(N)</option>
              <option value="S">(S)</option>
            </select>
          </div>
        </div>
        <div class="dms-group">
          <label>خط الطول (شرق W/E غرب):</label>
          <div class="dms-row">
            <input type="text" id="lonDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="lonHemisphere" class="hemisphere-select">
              <option value="E">(E)</option>
              <option value="W" selected>(W)</option>
            </select>
          </div>
        </div>
      </div>

      <div class="manual-fields" id="cartesianFields">
        <input type="text" id="manualX" placeholder="X">
        <input type="text" id="manualY" placeholder="Y">
      </div>

      <button class="manual-btn rounded" onclick="convertSingle()">تحويل الإحداثيات المدخلة</button>
      <button type="button" id="copySingleResultBtn" class="btntout mt-2 rounded" onclick="copySingleResult()" disabled>نسخ النتيجة</button>
      <div class="result single-result" id="singleResult"></div>
    </div>

    <div class="map-box">
      <h3>عرض النقطة على الخريطة</h3>
      <p class="hint">سيتم تحريك العلامة تلقائيًا إلى آخر نقطة تم تحويلها، ويمكنك وضع علامة جديدة عبر الضغط على زر "تحديد نقطة على الخريطة" ثم اختيار الموضع على الخريطة.</p>
      <div class="map-stage">
        <div id="map"></div>
        <div id="mapStatusMessage" class="map-status-message" role="status" aria-live="polite" hidden></div>
        <button type="button" id="mapFullscreenBtn" class="map-fullscreen-btn" onclick="toggleMapFullscreen()" aria-label="تكبير الخريطة لملء الشاشة" aria-pressed="false">تكبير الخريطة</button>
        <div class="map-wrapper dropdown ">
          <button id="mapActionsDropdownToggle" class="btn btn-primary dropdown-toggle d-inline-flex align-items-center gap-1 w-auto" data-bs-toggle="dropdown" data-bs-config='{"strategy":"fixed","boundary":"viewport"}'><i class="bi bi-gear-fill"></i></button> <!-- action -->
          <ul class="dropdown-menu dropdown-menu-center bg-white bg-opacity-50">
            
            <li class="d-flex justify-content-between">
              <button type="button" class="dropdown-item map-actions-close-btn text-center" onclick="handleMapActionsMenuClose(); return false;"><i class="bi bi-x-circle-fill"></i> اغلاق</button>
              <a class="dropdown-item fw-bold" href="#" onclick="locateUser(); return false;">
                <i class="bi bi-geo-alt-fill"></i> موقعي الحالي
              </a>
            </li>
            <li>
              <a class="dropdown-item fw-bold" id="manualPointSelectBtn" href="#" onclick="toggleManualPointSelection(); return false;">
                تحديد نقطة على الخريطة
              </a>
            </li>
            <li>
              <a class="dropdown-item fw-bold" id="startDistanceToolBtn" href="#" onclick="startDistanceFromMenu(); return false;">
                ➕ مسافة
              </a>
            </li>
            <li>
              <a class="dropdown-item fw-bold" id="basemapToggle" href="#" onclick="toggleBasemap(); return false;">
                التبديل بين الخرائط
              </a>
            </li>
            <li><hr class="dropdown-divider fw-bold"></li>
            <li>
              <span class="dropdown-item-text saved-points-label fw-bold">النقط المحددة</span>
            </li>
            <li>
              <div id="savedPointsContainer" class="px-3 saved-points-scroll">
                <button type="button" id="savedPointsBulkToggle" class="saved-points-bulk-btn" onclick="toggleAllSavedPointsVisibility()" disabled>إخفاء الكل</button>
                <div id="savedPointsEmpty" class="text-muted small">لا توجد نقاط محددة بعد.</div>
                <ul id="savedPointsList" class="saved-points-list list-unstyled mb-0"></ul>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>


  <div id="batchSection">
    <button type="button" id="batchSectionToggle" class="batch-toggle-btn d-inline-flex align-items-center gap-1 w-auto is-collapsed" aria-expanded="false" aria-controls="batchSectionContent" onclick="toggleBatchSection()">
      <span class="batch-toggle-label">تحويل عدة قيم</span>
      <span class="batch-toggle-icon" aria-hidden="true">+</span>
    </button>
    <div id="batchSectionContent" hidden>
      <label>اختر ملف CSV للإحداثيات (أعمدة X و Y):</label>
      <input type="file" id="csvFile" accept=".csv">
      <p class="hint" id="fileHint"></p>
      <img src="modelcsvxy.JPG" alt="نموذج ملف CSV" id="csvModelImage" class="csv-image">
      <button id="convertBtn" class="btntout rounded d-inline-flex align-items-center gap-1 w-auto my-3" onclick="convertCSV()" disabled>تحويل جميع الإحداثيات</button>
      <p class="hint" id="layoutHint">بعد التحويل، ضع قيمة Latitude في العمود A وقيمة Longitude في العمود B داخل ملف Excel قبل أي معالجة إضافية.</p>
      <div class="result" id="result"></div>
      <button id="downloadBtn" class="download-btn rounded d-inline-flex align-items-center gap-1 w-auto my-3" onclick="downloadConvertedFile()" disabled>تحميل الملف المحوّل</button>
    </div>
  </div>
</div>

<script>
  const wgs84 = proj4.WGS84;
  const merchichZones = {
    Zone_I: {
      label: 'Zone I (Rabat - Casablanca)',
      proj: '+proj=lcc +lat_1=33.3 +lat_0=33.3 +lon_0=-5.4 +k_0=0.999615596 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_II: {
      label: 'Zone II (Agadir - Marrakech)',
      proj: '+proj=lcc +lat_1=29.7 +lat_0=29.7 +lon_0=-5.4 +k_0=0.999615596 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_III: {
      label: 'Zone III (La\'youn)',
      proj: '+proj=lcc +lat_1=26.1 +lat_0=26.1 +lon_0=-5.4 +k_0=0.999615596 +x_0=1200000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_IV: {
      label: 'Zone IV (Ad-Dakhla)',
      proj: '+proj=lcc +lat_1=22.5 +lat_0=22.5 +lon_0=-5.4 +k_0=0.999615596 +x_0=1500000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    }
  };

  const zoneValidationLimits = {
    Zone_I: {
      latRange: { min: 31.72786641202, max: 34.8717272112 }
    },
    Zone_II: {
      latRange: { min: 28.10632948, max: 31.2932791054 }
    },
    Zone_III: {
      latRange: { min: 24.5075340813, max: 27.6921073632 }
    },
    Zone_IV: {
      latRange: { min: 20.9075742561, max: 24.092105054 }
    }
  };

  const MOROCCO_BOUNDARY = {
    type: 'Feature',
    geometry: {
      type: 'Polygon',
      coordinates: [[
        [-5.193863, 35.755182],
        [-4.591006, 35.330712],
        [-3.640057, 35.399855],
        [-2.604306, 35.179093],
        [-2.169914, 35.168396],
        [-1.792986, 34.527919],
        [-1.733455, 33.919713],
        [-1.388049, 32.864015],
        [-1.124551, 32.651522],
        [-1.307899, 32.262889],
        [-2.616605, 32.094346],
        [-3.06898, 31.724498],
        [-3.647498, 31.637294],
        [-3.690441, 30.896952],
        [-4.859646, 30.501188],
        [-5.242129, 30.000443],
        [-6.060632, 29.7317],
        [-7.059228, 29.579228],
        [-8.674116, 28.841289],
        [-8.66559, 27.656426],
        [-8.817809, 27.656426],
        [-8.817828, 27.656426],
        [-8.794884, 27.120696],
        [-9.413037, 27.088476],
        [-9.735343, 26.860945],
        [-10.189424, 26.860945],
        [-10.551263, 26.990808],
        [-11.392555, 26.883424],
        [-11.71822, 26.104092],
        [-12.030759, 26.030866],
        [-12.500963, 24.770116],
        [-13.89111, 23.691009],
        [-14.221168, 22.310163],
        [-14.630833, 21.86094],
        [-14.750955, 21.5006],
        [-17.002962, 21.420734],
        [-17.020428, 21.42231],
        [-16.973248, 21.885745],
        [-16.589137, 22.158234],
        [-16.261922, 22.67934],
        [-16.326414, 23.017768],
        [-15.982611, 23.723358],
        [-15.426004, 24.359134],
        [-15.089332, 24.520261],
        [-14.824645, 25.103533],
        [-14.800926, 25.636265],
        [-14.43994, 26.254418],
        [-13.773805, 26.618892],
        [-13.139942, 27.640148],
        [-13.121613, 27.654148],
        [-12.618837, 28.038186],
        [-11.688919, 28.148644],
        [-10.900957, 28.832142],
        [-10.399592, 29.098586],
        [-9.564811, 29.933574],
        [-9.814718, 31.177736],
        [-9.434793, 32.038096],
        [-9.300693, 32.564679],
        [-8.657476, 33.240245],
        [-7.654178, 33.697065],
        [-6.912544, 34.110476],
        [-6.244342, 35.145865],
        [-5.929994, 35.759988],
        [-5.193863, 35.755182]
      ]]
    }
  };
  const defaultZoneKey = 'Zone_I';
  let currentZoneKey = defaultZoneKey;
  let lastConvertedRows = [];
  let lastConvertedFields = null;
  let lastConversionType = null;
  const defaultMapCenter = [33.9, -5.3];
  const basemapConfigs = [
    {
      key: 'osmfr',
      label: 'plan de la ville',
      url: 'https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
      options: {
        attribution: '&copy; OpenStreetMap France & contributors',
        maxZoom: 19
      }
    },
    {
      key: 'imagery',
      label: 'satellite',
      url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      options: {
        attribution: 'Tiles &copy; Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        maxZoom: 19
      }
    }
  ];
  const MAX_FILE_SIZE_BYTES = 1024 * 1024;
  const MAX_CSV_ROWS = 200;
  const SAVED_POINTS_STORAGE_KEY = 'convertgps.savedManualPoints';
  let mapInstance = null;
  let mapTileLayer = null;
  let currentBasemapIndex = 0;
  let conversionMarker = null;
  let userMarker = null;
  let manualPointSelectionArmed = false;
  const savedManualPoints = [];
  const savedMeasurements = [];
  let manualPointSequence = 1;
  let measurementSequence = 1;
  let activeSavedPointId = '';
  let activeMeasurementId = '';
  let mapFullscreenActive = false;
  let userAccuracyCircle = null;
  let geoWatchId = null;
  let geoWatchTimeoutId = null;
  let coarseLocationWarned = false;
  let cityOptionsCache = [];
  let selectedCityName = '';
  const CITY_SUGGESTION_LIMIT = 20;
  const CITY_ALLOWED_CHAR_REGEX = /^[A-Za-z ]$/;
  const CITY_ALLOWED_TEXT_REGEX = /^[A-Za-z ]+$/;
  const LAT_INPUT_IDS = ['latDeg', 'latMin', 'latSec'];
  const LON_INPUT_IDS = ['lonDeg', 'lonMin', 'lonSec'];
  const CARTESIAN_INPUT_IDS = ['manualX', 'manualY'];
  const GEO_COORD_INPUT_IDS = [...LAT_INPUT_IDS, ...LON_INPUT_IDS];
  const ZONE_RANGE_ERROR_TEXT = 'النقطة خارج نطاق Zones المغربية';
  const MOROCCO_DOMAIN_ERROR_TEXT = 'النقطة خارج المجال الجغرافي للمغرب';
  const ZONE_MISMATCH_WARNING_TEMPLATE = 'هذه النقطة تقع في {actualZone}، وليس {selectedZone}.';
  let citySuggestionsHideTimeoutId = null;
  let measurementSelectionState = null;
  let mapStatusTimeoutId = null;
  const MAP_STATUS_VISIBILITY_MS = 4500;
  const measurementLineStyle = {
    color: '#fb923c',
    weight: 4,
    opacity: 0.95,
    dashArray: '10 7'
  };
  const measurementSelectionMarkers = { pointA: null, pointB: null };
  let mapActionsDropdownCanHide = false;
  const savedEntryDropdownPortals = new Map();
  let savedEntryDropdownEventsBound = false;
  let mapActionsDropdownPortalState = null;

  function toggleBatchSection() {
    const content = document.getElementById('batchSectionContent');
    const button = document.getElementById('batchSectionToggle');
    if(!content || !button) {
      return;
    }
    const isHidden = content.hasAttribute('hidden');
    if(isHidden) {
      content.removeAttribute('hidden');
      button.setAttribute('aria-expanded', 'true');
      button.classList.remove('is-collapsed');
      updateBatchToggleIcon(button, true);
    } else {
      content.setAttribute('hidden', '');
      button.setAttribute('aria-expanded', 'false');
      button.classList.add('is-collapsed');
      updateBatchToggleIcon(button, false);
    }
  }

  function updateBatchToggleIcon(button, isExpanded) {
    const icon = button.querySelector('.batch-toggle-icon');
    if(icon) {
      icon.textContent = isExpanded ? '-' : '+';
    }
  }

  function initMap() {
    const mapElement = document.getElementById('map');
    if(!mapElement || typeof L === 'undefined') {
      return;
    }
    mapInstance = L.map(mapElement, {
      zoomControl: false,
      scrollWheelZoom: false
    }).setView(defaultMapCenter, 6);

    L.control.zoom({ position: 'bottomright' }).addTo(mapInstance);

    L.control.scale({ position: 'bottomleft', metric: true, imperial: false }).addTo(mapInstance);

    applyBasemapLayer(currentBasemapIndex);
    mapInstance.on('click', handleMapClick);

  }

  function applyBasemapLayer(index) {
    if(!mapInstance || !basemapConfigs.length) {
      return;
    }
    const normalizedIndex = ((index % basemapConfigs.length) + basemapConfigs.length) % basemapConfigs.length;
    const config = basemapConfigs[normalizedIndex];
    if(!config) {
      return;
    }
    if(mapTileLayer) {
      mapInstance.removeLayer(mapTileLayer);
    }
    mapTileLayer = L.tileLayer(config.url, config.options).addTo(mapInstance);
    currentBasemapIndex = normalizedIndex;
    updateBasemapToggleLabel();
  }

  function toggleBasemap() {
    if(!mapInstance) {
      return;
    }
    const nextIndex = (currentBasemapIndex + 1) % basemapConfigs.length;
    applyBasemapLayer(nextIndex);
  }

  function toggleManualPointSelection() {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    setManualPointSelectionState(!manualPointSelectionArmed);
  }

  function setManualPointSelectionState(isActive) {
    if(isActive) {
      cancelMeasurementSelection();
    }
    manualPointSelectionArmed = Boolean(isActive);
    const mapElement = document.getElementById('map');
    if(mapElement) {
      mapElement.classList.toggle('map-select-armed', manualPointSelectionArmed);
    }
    updateManualPointSelectionUI();
  }

  function updateManualPointSelectionUI() {
    const button = document.getElementById('manualPointSelectBtn');
    if(!button) {
      return;
    }
    if(manualPointSelectionArmed) {
      button.classList.add('is-armed');
      button.textContent = 'اضغط على الخريطة الآن';
    } else {
      button.classList.remove('is-armed');
      button.textContent = 'تحديد نقطة على الخريطة';
    }
    button.setAttribute('aria-pressed', manualPointSelectionArmed ? 'true' : 'false');
  }

  function closeMapActionsDropdown() {
    const toggleButton = document.getElementById('mapActionsDropdownToggle');
    if(!toggleButton || typeof bootstrap === 'undefined' || !bootstrap.Dropdown) {
      return;
    }
    let dropdownInstance = bootstrap.Dropdown.getInstance(toggleButton);
    if(!dropdownInstance) {
      dropdownInstance = new bootstrap.Dropdown(toggleButton);
    }
    mapActionsDropdownCanHide = true;
    dropdownInstance.hide();
    window.setTimeout(() => {
      mapActionsDropdownCanHide = false;
    }, 0);
  }

  function initMapActionsDropdownGuard() {
    const toggleButton = document.getElementById('mapActionsDropdownToggle');
    if(!toggleButton || typeof bootstrap === 'undefined' || !bootstrap.Dropdown) {
      return;
    }
    toggleButton.addEventListener('show.bs.dropdown', portalizeMapActionsDropdownMenu);
    toggleButton.addEventListener('hide.bs.dropdown', (event) => {
      if(!mapActionsDropdownCanHide) {
        event.preventDefault();
      }
    });
    toggleButton.addEventListener('hidden.bs.dropdown', restoreMapActionsDropdownMenu);
  }

  function getMapActionsDropdownElements() {
    const toggleButton = document.getElementById('mapActionsDropdownToggle');
    if(!toggleButton) {
      return { toggleButton: null, menuElement: null };
    }
    const menuElement = toggleButton.nextElementSibling;
    return { toggleButton, menuElement: menuElement && menuElement.classList.contains('dropdown-menu') ? menuElement : null };
  }

  function getMapActionsPortalHost() {
    return document.querySelector('.map-stage')
      || document.querySelector('.map-box')
      || document.querySelector('.map-wrapper')
      || document.body;
  }

  function portalizeMapActionsDropdownMenu() {
    if(mapActionsDropdownPortalState) {
      return;
    }
    const { menuElement } = getMapActionsDropdownElements();
    if(!menuElement) {
      return;
    }
    const host = getMapActionsPortalHost();
    if(!host) {
      return;
    }
    const placeholder = document.createComment('map-actions-menu-home');
    menuElement.parentNode.insertBefore(placeholder, menuElement);
    host.appendChild(menuElement);
    menuElement.classList.add('map-actions-dropdown-portal');
    mapActionsDropdownPortalState = { menuElement, placeholder };
  }

  function restoreMapActionsDropdownMenu() {
    if(!mapActionsDropdownPortalState) {
      return;
    }
    const { menuElement, placeholder } = mapActionsDropdownPortalState;
    if(menuElement && placeholder) {
      if(placeholder.parentNode) {
        placeholder.parentNode.insertBefore(menuElement, placeholder);
        placeholder.parentNode.removeChild(placeholder);
      } else {
        const fallbackParent = document.querySelector('.map-wrapper') || document.querySelector('.map-stage') || document.body;
        if(fallbackParent) {
          fallbackParent.appendChild(menuElement);
        }
      }
    }
    if(menuElement) {
      menuElement.classList.remove('map-actions-dropdown-portal');
    }
    mapActionsDropdownPortalState = null;
  }

  function handleMapActionsMenuClose() {
    closeMapActionsDropdown();
  }

  function setMapStatusMessage(message, { persistent = false } = {}) {
    const banner = document.getElementById('mapStatusMessage');
    if(mapStatusTimeoutId) {
      clearTimeout(mapStatusTimeoutId);
      mapStatusTimeoutId = null;
    }
    if(!banner) {
      return;
    }
    if(!message) {
      banner.textContent = '';
      banner.hidden = true;
      return;
    }
    banner.textContent = message;
    banner.hidden = false;
    if(!persistent) {
      mapStatusTimeoutId = window.setTimeout(() => {
        clearMapStatusMessage();
      }, MAP_STATUS_VISIBILITY_MS);
    }
  }

  function clearMapStatusMessage() {
    const banner = document.getElementById('mapStatusMessage');
    if(mapStatusTimeoutId) {
      clearTimeout(mapStatusTimeoutId);
      mapStatusTimeoutId = null;
    }
    if(banner) {
      banner.textContent = '';
      banner.hidden = true;
    }
  }

  function setDistanceSelectionMode(isActive) {
    const mapElement = document.getElementById('map');
    if(mapElement) {
      mapElement.classList.toggle('map-distance-armed', Boolean(isActive));
    }
  }

  function setMeasurementSelectionMarker(key, endpoint) {
    if(!mapInstance || (key !== 'pointA' && key !== 'pointB')) {
      return;
    }
    if(!endpoint) {
      if(measurementSelectionMarkers[key]) {
        mapInstance.removeLayer(measurementSelectionMarkers[key]);
        measurementSelectionMarkers[key] = null;
      }
      return;
    }
    const latlng = [endpoint.lat, endpoint.lon];
    const label = key === 'pointA' ? 'A' : 'B';
    if(measurementSelectionMarkers[key]) {
      measurementSelectionMarkers[key].setLatLng(latlng);
      return;
    }
    measurementSelectionMarkers[key] = L.marker(latlng, {
      interactive: false,
      icon: L.divIcon({
        className: '',
        html: `<div class="distance-selection-marker">${label}</div>`,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      })
    }).addTo(mapInstance);
  }

  function clearMeasurementSelectionMarkers() {
    if(!mapInstance) {
      measurementSelectionMarkers.pointA = null;
      measurementSelectionMarkers.pointB = null;
      return;
    }
    ['pointA', 'pointB'].forEach((key) => {
      if(measurementSelectionMarkers[key]) {
        mapInstance.removeLayer(measurementSelectionMarkers[key]);
        measurementSelectionMarkers[key] = null;
      }
    });
  }

  function toggleMapFullscreen() {
    mapFullscreenActive = !mapFullscreenActive;
    const bodyElement = document.body;
    if(bodyElement) {
      bodyElement.classList.toggle('map-fullscreen-active', mapFullscreenActive);
    }
    updateMapFullscreenUI();
    if(mapInstance) {
      mapInstance.invalidateSize();
      window.setTimeout(() => {
        mapInstance && mapInstance.invalidateSize();
      }, 300);
    }
  }

  function updateMapFullscreenUI() {
    const button = document.getElementById('mapFullscreenBtn');
    if(!button) {
      return;
    }
    const label = mapFullscreenActive ? 'إغلاق وضع تكبير الخريطة' : 'تكبير الخريطة لملء الشاشة';
    button.textContent = mapFullscreenActive ? 'تصغير الخريطة' : 'تكبير الخريطة';
    button.setAttribute('aria-label', label);
    button.setAttribute('aria-pressed', mapFullscreenActive ? 'true' : 'false');
  }

  function getConversionMarkerPopupHtml(bodyHtml) {
    const safeBody = bodyHtml || 'تم تثبيت النقطة.';
    return `
      <div class="marker-popover">
        <button type="button" class="marker-remove-btn" aria-label="حذف النقطة" onclick="removeConversionMarker()">حذف</button>
        <div class="marker-popover-body">${safeBody}</div>
      </div>
    `;
  }

  function updateBasemapToggleLabel() {
    const toggleBtn = document.getElementById('basemapToggle');
    const nextMenuItem = document.getElementById('nextBasemapMenuItem');
    if(!toggleBtn) {
      return;
    }
    const current = basemapConfigs[currentBasemapIndex];
    const next = basemapConfigs[(currentBasemapIndex + 1) % basemapConfigs.length];
    toggleBtn.textContent = ` ( الانتقال إلى ${next.label})`;
    toggleBtn.setAttribute('aria-label', `التبديل من ${current.label} إلى ${next.label}`);
    toggleBtn.setAttribute('aria-pressed', current.key === 'imagery' ? 'true' : 'false');
    if(nextMenuItem) {
      nextMenuItem.textContent = ` ( الانتقال إلى ${next.label})`;
    }
  }

  function updateConversionMarker(latitude, longitude, labelText, zoomLevel = 14) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!conversionMarker) {
      conversionMarker = L.circleMarker(target, {
        radius: 10,
        color: '#1f6de2',
        fillColor: '#1f6de2',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      conversionMarker.setLatLng(target);
    }
    const popupHtml = getConversionMarkerPopupHtml(labelText);
    conversionMarker.bindPopup(popupHtml).openPopup();
    mapInstance.setView(target, zoomLevel);
  }

  function removeConversionMarker() {
    if(conversionMarker && mapInstance) {
      mapInstance.removeLayer(conversionMarker);
      conversionMarker = null;
    }
    if(mapInstance) {
      mapInstance.closePopup();
    }
  }

  function updateUserLocationMarker(latitude, longitude, labelText, zoomLevel = 16) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!userMarker) {
      userMarker = L.circleMarker(target, {
        radius: 10,
        color: '#1fa86d',
        fillColor: '#1fa86d',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      userMarker.setLatLng(target);
    }
    if(labelText) {
      userMarker.bindPopup(labelText).openPopup();
    }
    mapInstance.setView(target, zoomLevel);
  }

  function handleMapClick(event) {
    if(!event || !event.latlng) {
      return;
    }
    const latitude = event.latlng.lat;
    const longitude = event.latlng.lng;
    if(handleMeasurementPointSelection(latitude, longitude)) {
      return;
    }
    if(!manualPointSelectionArmed) {
      return;
    }
    setManualPointSelectionState(false);
    setDmsInputsFromDecimal(latitude, longitude);
    addManualPoint(latitude, longitude);
    const conversionTypeElement = document.getElementById('conversionType');
    if(conversionTypeElement && conversionTypeElement.value === 'latlong-to-Merchich') {
      convertSingle();
    }
  }

  function generateSavedPointName() {
    const label = `نقطة ${manualPointSequence}`;
    manualPointSequence += 1;
    return label;
  }

  function escapeHtml(value) {
    if(value === null || value === undefined) {
      return '';
    }
    const lookup = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return value.toString().replace(/[&<>"']/g, (char) => lookup[char] || char);
  }

  function getVisibilityToggleUi(isVisible, subjectLabel = '') {
    const iconClass = isVisible ? 'bi-eye' : 'bi-eye-slash';
    const action = isVisible ? 'إخفاء' : 'عرض';
    const ariaLabel = subjectLabel ? `${action} ${subjectLabel}` : action;
    const statusLabel = isVisible ? 'ظاهر' : 'مخفي';
    const statusDescription = subjectLabel ? `${subjectLabel} ${statusLabel}` : statusLabel;
    return {
      iconHtml: `<i class="bi ${iconClass}" aria-hidden="true"></i>`,
      ariaLabel,
      actionLabel: action,
      statusLabel,
      statusDescription
    };
  }

  function findSavedPoint(pointId) {
    return savedManualPoints.find((point) => point.id === pointId) || null;
  }

  function getSavedPointsVisibilityStats() {
    const visibilityFlags = [
      ...savedManualPoints.map((point) => point.visible),
      ...savedMeasurements.map((measurement) => measurement.visible)
    ];
    const total = visibilityFlags.length;
    const visible = visibilityFlags.reduce((count, flag) => count + (flag ? 1 : 0), 0);
    return { total, visible };
  }

  function updateSavedPointsBulkButton() {
    const button = document.getElementById('savedPointsBulkToggle');
    if(!button) {
      return;
    }
    const { total, visible } = getSavedPointsVisibilityStats();
    button.disabled = total === 0;
    if(total === 0) {
      button.textContent = 'إخفاء الكل';
      button.dataset.action = 'hide';
      return;
    }
    const shouldShow = visible === 0;
    button.textContent = shouldShow ? 'إظهار الكل' : 'إخفاء الكل';
    button.dataset.action = shouldShow ? 'show' : 'hide';
  }

  function persistSavedPointsState() {
    if(typeof window === 'undefined' || !window.localStorage) {
      return;
    }
    const payload = {
      manualPointSequence,
      measurementSequence,
      points: savedManualPoints.map(({ id, name, lat, lon, visible }) => ({ id, name, lat, lon, visible })),
      measurements: savedMeasurements.map(({ id, name, pointA, pointB, visible }) => ({
        id,
        name,
        visible,
        pointA: { lat: pointA.lat, lon: pointA.lon, refPointId: pointA.refPointId || null },
        pointB: { lat: pointB.lat, lon: pointB.lon, refPointId: pointB.refPointId || null }
      }))
    };
    try {
      window.localStorage.setItem(SAVED_POINTS_STORAGE_KEY, JSON.stringify(payload));
    } catch (error) {
      console.error('تعذر حفظ النقاط المحددة محليًا', error);
    }
  }

  function loadSavedPointsFromStorage() {
    if(typeof window === 'undefined' || !window.localStorage) {
      return;
    }
    let payload = null;
    try {
      const serialized = window.localStorage.getItem(SAVED_POINTS_STORAGE_KEY);
      if(!serialized) {
        return;
      }
      payload = JSON.parse(serialized);
    } catch (error) {
      console.error('تعذر قراءة النقاط المحفوظة', error);
      return;
    }
    if(!payload || !Array.isArray(payload.points)) {
      return;
    }
    if(Number.isFinite(payload.manualPointSequence)) {
      manualPointSequence = payload.manualPointSequence;
    }
    if(Number.isFinite(payload.measurementSequence)) {
      measurementSequence = payload.measurementSequence;
    }
    payload.points.forEach((data) => {
      if(!Number.isFinite(data.lat) || !Number.isFinite(data.lon)) {
        return;
      }
      const point = {
        id: data.id || `manual-point-${Date.now()}-${manualPointSequence++}`,
        name: typeof data.name === 'string' && data.name.trim() ? data.name.trim() : generateSavedPointName(),
        lat: data.lat,
        lon: data.lon,
        visible: data.visible !== false,
        marker: null
      };
      savedManualPoints.push(point);
      createMarkerForPoint(point);
    });
    if(Array.isArray(payload.measurements)) {
      payload.measurements.forEach((data) => {
        const pointA = createMeasurementEndpoint(data?.pointA?.lat, data?.pointA?.lon, data?.pointA?.refPointId);
        const pointB = createMeasurementEndpoint(data?.pointB?.lat, data?.pointB?.lon, data?.pointB?.refPointId);
        if(!pointA || !pointB) {
          return;
        }
        const measurement = {
          id: data.id || `measurement-${Date.now()}-${measurementSequence++}`,
          name: typeof data.name === 'string' && data.name.trim() ? data.name.trim() : generateMeasurementNameFromEndpoints(pointA, pointB),
          pointA,
          pointB,
          visible: data.visible !== false,
          polyline: null
        };
        savedMeasurements.push(measurement);
        createPolylineForMeasurement(measurement);
      });
    }
    renderSavedPointsList();
  }

  function createMarkerForPoint(point) {
    if(!mapInstance || !point) {
      return null;
    }
    const marker = L.circleMarker([point.lat, point.lon], {
      radius: 9,
      color: '#c026d3',
      fillColor: '#f472b6',
      fillOpacity: 0.95,
      weight: 2
    });
    marker.on('click', (event) => {
      if(handleMeasurementPointSelection(point.lat, point.lon, { refPointId: point.id })) {
        if(event && event.originalEvent) {
          event.originalEvent.preventDefault();
        }
        return;
      }
      focusSavedPoint(point.id, { openPopup: true });
    });
    if(point.visible) {
      marker.addTo(mapInstance);
    }
    point.marker = marker;
    updateSavedPointPopup(point);
    if(!point.visible && mapInstance.hasLayer(marker)) {
      mapInstance.removeLayer(marker);
    }
    return marker;
  }

  function addManualPoint(latitude, longitude) {
    if(!mapInstance || !Number.isFinite(latitude) || !Number.isFinite(longitude)) {
      return null;
    }
    const pointId = `manual-point-${Date.now()}-${manualPointSequence}`;
    const pointName = generateSavedPointName();
    const point = { id: pointId, name: pointName, lat: latitude, lon: longitude, marker: null, visible: true };
    savedManualPoints.push(point);
    createMarkerForPoint(point);
    renderSavedPointsList();
    focusSavedPoint(pointId, { openPopup: true, skipRender: true });
    persistSavedPointsState();
    return point;
  }

  function updateSavedPointPopup(point) {
    if(!point || !point.marker) {
      return;
    }
    const latText = formatDMS(decimalToDMS(point.lat, true));
    const lonText = formatDMS(decimalToDMS(point.lon, false));
    const safeName = escapeHtml(point.name);
    const { iconHtml: visibilityIconHtml, ariaLabel: visibilityAriaLabel } = getVisibilityToggleUi(point.visible, 'النقطة');
    const popupHtml = `
      <div class="marker-popover">
        <div class="marker-popover-title">${safeName}</div>
        <div class="marker-popover-body">${wrapDmsHtml(latText, lonText)}</div>
        <div class="marker-popover-actions">
          <button type="button" class="marker-action-btn" onclick="toggleSavedPointVisibility('${point.id}'); return false;" aria-label="${visibilityAriaLabel}" title="${visibilityAriaLabel}">${visibilityIconHtml}</button>
          <button type="button" class="marker-action-btn" onclick="renameSavedPoint('${point.id}'); return false;">تعديل الاسم</button>
          <button type="button" class="marker-action-btn" onclick="startDistanceFromPoint('${point.id}'); return false;">مسافة</button>
          <button type="button" class="marker-action-btn danger" onclick="removeSavedPoint('${point.id}'); return false;">حذف</button>
        </div>
      </div>
    `;
    point.marker.bindPopup(popupHtml);
  }

  function renderSavedPointsList() {
    const listElement = document.getElementById('savedPointsList');
    const emptyState = document.getElementById('savedPointsEmpty');
    if(!listElement || !emptyState) {
      return;
    }
    dismissAllSavedEntryDropdownMenus();
    initSavedEntryDropdownPortals();
    const hasPoints = savedManualPoints.length > 0;
    const hasMeasurements = savedMeasurements.length > 0;
    if(!hasPoints && !hasMeasurements) {
      listElement.innerHTML = '';
      emptyState.hidden = false;
      activeSavedPointId = '';
      activeMeasurementId = '';
      updateSavedPointsBulkButton();
      return;
    }
    emptyState.hidden = true;
    const pointItems = savedManualPoints.map((point) => {
      const isActive = point.id === activeSavedPointId ? ' is-active' : '';
      const safeName = escapeHtml(point.name);
      const latDmsText = formatDMS(decimalToDMS(point.lat, true));
      const lonDmsText = formatDMS(decimalToDMS(point.lon, false));
      const coords = `${latDmsText} • ${lonDmsText}`;
      const { iconHtml: visibilityIconHtml, statusLabel, statusDescription } = getVisibilityToggleUi(point.visible, 'النقطة');
      const toggleId = `savedEntryToggle-point-${point.id}`;
      const menuHtml = getPointActionsMenuHtml(point);
      return `
        <li class="saved-point-item saved-entry-dropdown dropup${isActive}" data-point-id="${point.id}">
          <button type="button" id="${toggleId}" class="saved-point-link dropdown-toggle" data-bs-toggle="dropdown" data-bs-config='{"strategy":"fixed","boundary":"viewport"}' aria-expanded="false">
            <div class="saved-point-text">
              <span class="saved-point-name">${safeName}</span>
              <span class="saved-point-coords">${coords}</span>
            </div>
            <span class="saved-entry-visibility ${point.visible ? 'is-visible' : 'is-hidden'}" aria-label="${statusDescription}" title="${statusDescription}">
              ${visibilityIconHtml}
              <span class="saved-entry-status-text">${statusLabel}</span>
            </span>
          </button>
          <div class="dropdown-menu saved-entry-actions-menu" aria-labelledby="${toggleId}">
            ${menuHtml}
          </div>
        </li>
      `;
    });
    const measurementItems = savedMeasurements.map((measurement) => {
      const isActive = measurement.id === activeMeasurementId ? ' is-active' : '';
      const safeName = escapeHtml(measurement.name);
      const { iconHtml: visibilityIconHtml, statusLabel, statusDescription } = getVisibilityToggleUi(measurement.visible, 'المسافة');
      const distanceLabel = formatMeasurementDistance(measurement);
      const toggleId = `savedEntryToggle-measurement-${measurement.id}`;
      const menuHtml = getMeasurementActionsMenuHtml(measurement);
      return `
        <li class="saved-distance-item saved-entry-dropdown dropup${isActive}" data-measurement-id="${measurement.id}">
          <button type="button" id="${toggleId}" class="saved-point-link dropdown-toggle" data-bs-toggle="dropdown" data-bs-config='{"strategy":"fixed","boundary":"viewport"}' aria-expanded="false">
            <div class="saved-point-text">
              <span class="saved-point-name">${safeName}</span>
              <span class="saved-distance-value">${distanceLabel}</span>
            </div>
            <span class="saved-entry-visibility ${measurement.visible ? 'is-visible' : 'is-hidden'}" aria-label="${statusDescription}" title="${statusDescription}">
              ${visibilityIconHtml}
              <span class="saved-entry-status-text">${statusLabel}</span>
            </span>
          </button>
          <div class="dropdown-menu saved-entry-actions-menu" aria-labelledby="${toggleId}">
            ${menuHtml}
          </div>
        </li>
      `;
    });
    listElement.innerHTML = [...pointItems, ...measurementItems].join('');
    updateSavedPointsBulkButton();
  }

  function getSavedEntryDropdownPortalHost() {
    if(document && document.body) {
      return document.body;
    }
    return document.querySelector('.map-stage')
      || document.querySelector('.map-box')
      || document.querySelector('.map-wrapper');
  }

  function isSavedEntryDropdownToggle(element) {
    return Boolean(element
      && element.classList
      && element.classList.contains('saved-point-link')
      && element.closest('.saved-entry-dropdown'));
  }

  function portalizeSavedEntryDropdownMenu(toggleElement) {
    if(!toggleElement) {
      return;
    }
    const dropdownRoot = toggleElement.closest('.saved-entry-dropdown');
    if(!dropdownRoot) {
      return;
    }
    const menu = dropdownRoot.querySelector('.dropdown-menu');
    if(!menu || savedEntryDropdownPortals.has(menu)) {
      if(menu) {
        toggleElement.__savedEntryDropdownMenu = menu;
      }
      return;
    }
    const host = getSavedEntryDropdownPortalHost();
    if(!host) {
      return;
    }
    const placeholder = document.createComment('saved-entry-menu-home');
    dropdownRoot.insertBefore(placeholder, menu);
    host.appendChild(menu);
    menu.classList.add('saved-entry-actions-menu-portal');
    savedEntryDropdownPortals.set(menu, {
      placeholder,
      toggle: toggleElement,
      originParent: dropdownRoot
    });
    toggleElement.__savedEntryDropdownMenu = menu;
  }

  function restoreSavedEntryDropdownMenu(toggleElement, menuElement = null) {
    const menu = menuElement || (toggleElement ? toggleElement.__savedEntryDropdownMenu : null);
    if(!menu) {
      return;
    }
    const portalState = savedEntryDropdownPortals.get(menu);
    if(!portalState) {
      if(toggleElement && toggleElement.__savedEntryDropdownMenu === menu) {
        delete toggleElement.__savedEntryDropdownMenu;
      }
      return;
    }
    const { placeholder, originParent } = portalState;
    if(placeholder && placeholder.parentNode) {
      placeholder.parentNode.insertBefore(menu, placeholder);
      placeholder.parentNode.removeChild(placeholder);
    } else {
      const fallbackParent = originParent || document.getElementById('savedPointsList');
      if(fallbackParent) {
        fallbackParent.appendChild(menu);
      }
    }
    menu.classList.remove('saved-entry-actions-menu-portal');
    savedEntryDropdownPortals.delete(menu);
    if(toggleElement && toggleElement.__savedEntryDropdownMenu === menu) {
      delete toggleElement.__savedEntryDropdownMenu;
    }
  }

  function dismissAllSavedEntryDropdownMenus() {
    if(!savedEntryDropdownPortals.size) {
      return;
    }
    const activeMenus = Array.from(savedEntryDropdownPortals.entries());
    activeMenus.forEach(([menu, state]) => {
      const toggleElement = state?.toggle || null;
      if(toggleElement && typeof bootstrap !== 'undefined' && bootstrap.Dropdown) {
        const instance = bootstrap.Dropdown.getInstance(toggleElement);
        if(instance) {
          instance.hide();
          return;
        }
      }
      restoreSavedEntryDropdownMenu(toggleElement, menu);
    });
  }

  function handleSavedEntryDropdownShow(event) {
    const toggleElement = event?.target;
    if(!isSavedEntryDropdownToggle(toggleElement)) {
      return;
    }
    portalizeSavedEntryDropdownMenu(toggleElement);
  }

  function handleSavedEntryDropdownHide(event) {
    const toggleElement = event?.target;
    if(!isSavedEntryDropdownToggle(toggleElement)) {
      return;
    }
    restoreSavedEntryDropdownMenu(toggleElement);
  }

  function initSavedEntryDropdownPortals() {
    if(savedEntryDropdownEventsBound) {
      return;
    }
    const listElement = document.getElementById('savedPointsList');
    if(!listElement) {
      return;
    }
    savedEntryDropdownEventsBound = true;
    listElement.addEventListener('show.bs.dropdown', handleSavedEntryDropdownShow);
    listElement.addEventListener('hide.bs.dropdown', handleSavedEntryDropdownHide);
  }

  function getPointActionsMenuHtml(point) {
    const safeName = escapeHtml(point.name);
    const latText = formatDMS(decimalToDMS(point.lat, true));
    const lonText = formatDMS(decimalToDMS(point.lon, false));
    const coordsHtml = wrapDmsHtml(latText, lonText);
    const { actionLabel: visibilityActionLabel, ariaLabel: visibilityAriaLabel } = getVisibilityToggleUi(point.visible, 'النقطة');
    return `
      <div class="saved-entry-menu-header">
        <div class="saved-entry-menu-label">نقطة</div>
        <div class="saved-entry-menu-title">${safeName}</div>
        <div class="saved-entry-menu-meta">${coordsHtml}</div>
      </div>
      <hr class="dropdown-divider">
      <button type="button" class="dropdown-item saved-entry-action-item primary" onclick="focusSavedPoint('${point.id}', { openPopup: true }); return false;">انتقال</button>
      <button type="button" class="dropdown-item saved-entry-action-item" onclick="toggleSavedPointVisibility('${point.id}'); return false;" aria-label="${visibilityAriaLabel}" title="${visibilityAriaLabel}">${visibilityActionLabel}</button>
      <button type="button" class="dropdown-item saved-entry-action-item" onclick="renameSavedPoint('${point.id}'); return false;">تعديل الاسم</button>
      <button type="button" class="dropdown-item saved-entry-action-item" onclick="startDistanceFromPoint('${point.id}'); return false;">مسافة</button>
      <button type="button" class="dropdown-item saved-entry-action-item danger" onclick="removeSavedPoint('${point.id}'); return false;">حذف</button>
    `;
  }

  function getMeasurementActionsMenuHtml(measurement) {
    const safeName = escapeHtml(measurement.name);
    const distanceLabel = formatMeasurementDistance(measurement);
    const { actionLabel: visibilityActionLabel, ariaLabel: visibilityAriaLabel } = getVisibilityToggleUi(measurement.visible, 'المسافة');
    const endpointASummary = formatMeasurementEndpointSummary(measurement.pointA, 'النقطة A');
    const endpointBSummary = formatMeasurementEndpointSummary(measurement.pointB, 'النقطة B');
    return `
      <div class="saved-entry-menu-header">
        <div class="saved-entry-menu-label">مسافة</div>
        <div class="saved-entry-menu-title">${safeName}</div>
        <div class="saved-entry-menu-meta">
          <div>المسافة: <span class="measurement-distance-value">${distanceLabel}</span></div>
          <div>${endpointASummary}</div>
          <div>${endpointBSummary}</div>
        </div>
      </div>
      <hr class="dropdown-divider">
      <button type="button" class="dropdown-item saved-entry-action-item primary" onclick="focusMeasurement('${measurement.id}', { openPopup: true }); return false;">انتقال</button>
      <button type="button" class="dropdown-item saved-entry-action-item" onclick="toggleMeasurementVisibility('${measurement.id}'); return false;" aria-label="${visibilityAriaLabel}" title="${visibilityAriaLabel}">${visibilityActionLabel}</button>
      <button type="button" class="dropdown-item saved-entry-action-item" onclick="renameMeasurement('${measurement.id}'); return false;">تعديل الاسم</button>
      <button type="button" class="dropdown-item saved-entry-action-item" onclick="editMeasurementEndpoint('${measurement.id}', 'pointA'); return false;">تعديل النقطة A</button>
      <button type="button" class="dropdown-item saved-entry-action-item" onclick="editMeasurementEndpoint('${measurement.id}', 'pointB'); return false;">تعديل النقطة B</button>
      <button type="button" class="dropdown-item saved-entry-action-item danger" onclick="removeMeasurement('${measurement.id}'); return false;">حذف</button>
    `;
  }

  function createMeasurementEndpoint(lat, lon, refPointId = null) {
    const numericLat = Number(lat);
    const numericLon = Number(lon);
    if(!Number.isFinite(numericLat) || !Number.isFinite(numericLon)) {
      return null;
    }
    return {
      lat: numericLat,
      lon: numericLon,
      refPointId: typeof refPointId === 'string' ? refPointId : null
    };
  }

  function findMeasurement(measurementId) {
    return savedMeasurements.find((measurement) => measurement.id === measurementId) || null;
  }

  function generateMeasurementName() {
    const base = 'A → B';
    const label = measurementSequence === 1 ? base : `${base} (${measurementSequence})`;
    measurementSequence += 1;
    return label;
  }

  function getPointLabelFromReference(refPointId) {
    if(!refPointId) {
      return null;
    }
    const point = findSavedPoint(refPointId);
    return point ? point.name : null;
  }

  function generateMeasurementNameFromEndpoints(pointA, pointB) {
    const labelA = pointA ? getPointLabelFromReference(pointA.refPointId) : null;
    const labelB = pointB ? getPointLabelFromReference(pointB.refPointId) : null;
    if(labelA && labelB) {
      return `${labelA} → ${labelB}`;
    }
    return generateMeasurementName();
  }

  function formatMeasurementEndpointSummary(endpoint, label) {
    const safeLabel = escapeHtml(label);
    if(!endpoint) {
      return `${safeLabel}: —`;
    }
    const referencedName = endpoint.refPointId ? getPointLabelFromReference(endpoint.refPointId) : null;
    if(referencedName) {
      return `${safeLabel}: ${escapeHtml(referencedName)}`;
    }
    const latText = formatDMS(decimalToDMS(endpoint.lat, true));
    const lonText = formatDMS(decimalToDMS(endpoint.lon, false));
    return `${safeLabel}: ${latText} • ${lonText}`;
  }

  function computeDistanceMeters(pointA, pointB) {
    if(!pointA || !pointB) {
      return NaN;
    }
    const toRadians = (value) => value * Math.PI / 180;
    const lat1 = toRadians(pointA.lat);
    const lat2 = toRadians(pointB.lat);
    const deltaLat = toRadians(pointB.lat - pointA.lat);
    const deltaLon = toRadians(pointB.lon - pointA.lon);
    const sinLat = Math.sin(deltaLat / 2);
    const sinLon = Math.sin(deltaLon / 2);
    const a = sinLat * sinLat + Math.cos(lat1) * Math.cos(lat2) * sinLon * sinLon;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const EARTH_RADIUS_METERS = 6371000;
    return EARTH_RADIUS_METERS * c;
  }

  function formatMeasurementDistance(measurement) {
    const meters = computeDistanceMeters(measurement?.pointA, measurement?.pointB);
    if(!Number.isFinite(meters)) {
      return '—';
    }
    if(meters < 1000) {
      return `${Math.round(meters)} m`;
    }
    return `${(meters / 1000).toFixed(2)} km`;
  }

  function createPolylineForMeasurement(measurement) {
    if(!measurement || !mapInstance) {
      return null;
    }
    const latlngs = [
      [measurement.pointA.lat, measurement.pointA.lon],
      [measurement.pointB.lat, measurement.pointB.lon]
    ];
    if(!measurement.polyline) {
      measurement.polyline = L.polyline(latlngs, measurementLineStyle);
      measurement.polyline.on('click', (event) => {
        if(event && event.originalEvent) {
          event.originalEvent.preventDefault();
        }
        focusMeasurement(measurement.id, { openPopup: true });
        if(event && event.latlng) {
          measurement.polyline.openPopup(event.latlng);
        }
      });
    } else {
      measurement.polyline.setLatLngs(latlngs);
    }
    if(measurement.visible) {
      measurement.polyline.addTo(mapInstance);
    } else if(mapInstance.hasLayer(measurement.polyline)) {
      mapInstance.removeLayer(measurement.polyline);
    }
    updateMeasurementPopup(measurement);
    return measurement.polyline;
  }

  function updateMeasurementPopup(measurement) {
    if(!measurement || !measurement.polyline) {
      return;
    }
    const safeName = escapeHtml(measurement.name);
    const { iconHtml: visibilityIconHtml, ariaLabel: visibilityAriaLabel } = getVisibilityToggleUi(measurement.visible, 'المسافة');
    const distanceLabel = formatMeasurementDistance(measurement);
    const popupHtml = `
      <div class="marker-popover">
        <div class="marker-popover-title">${safeName}</div>
        <div class="marker-popover-body">
          <span class="measurement-distance-value">${distanceLabel}</span>
        </div>
        <div class="marker-popover-actions">
          <button type="button" class="marker-action-btn" onclick="renameMeasurement('${measurement.id}'); return false;">تعديل الاسم</button>
          <button type="button" class="marker-action-btn" onclick="toggleMeasurementVisibility('${measurement.id}'); return false;" aria-label="${visibilityAriaLabel}" title="${visibilityAriaLabel}">${visibilityIconHtml}</button>
          <button type="button" class="marker-action-btn" onclick="editMeasurementEndpoint('${measurement.id}', 'pointA'); return false;">تعديل النقطة A</button>
          <button type="button" class="marker-action-btn" onclick="editMeasurementEndpoint('${measurement.id}', 'pointB'); return false;">تعديل النقطة B</button>
          <button type="button" class="marker-action-btn danger" onclick="removeMeasurement('${measurement.id}'); return false;">حذف</button>
        </div>
      </div>
    `;
    measurement.polyline.bindPopup(popupHtml);
  }

  function addMeasurement(pointA, pointB, options = {}) {
    const endpointA = createMeasurementEndpoint(pointA?.lat, pointA?.lon, pointA?.refPointId);
    const endpointB = createMeasurementEndpoint(pointB?.lat, pointB?.lon, pointB?.refPointId);
    if(!endpointA || !endpointB) {
      return null;
    }
    const measurement = {
      id: options.id || `measurement-${Date.now()}-${Math.floor(Math.random() * 1e6)}`,
      name: typeof options.name === 'string' && options.name.trim() ? options.name.trim() : generateMeasurementNameFromEndpoints(endpointA, endpointB),
      pointA: endpointA,
      pointB: endpointB,
      visible: options.visible !== false,
      polyline: null
    };
    savedMeasurements.push(measurement);
    if(mapInstance) {
      createPolylineForMeasurement(measurement);
    }
    focusMeasurement(measurement.id, { openPopup: true, skipRender: true });
    renderSavedPointsList();
    persistSavedPointsState();
    return measurement;
  }

  function removeMeasurement(measurementId) {
    const index = savedMeasurements.findIndex((measurement) => measurement.id === measurementId);
    if(index === -1) {
      return;
    }
    const [removed] = savedMeasurements.splice(index, 1);
    if(measurementSelectionState && measurementSelectionState.measurementId === measurementId) {
      cancelMeasurementSelection();
    }
    if(removed && removed.polyline && mapInstance) {
      mapInstance.removeLayer(removed.polyline);
    }
    if(activeMeasurementId === measurementId) {
      activeMeasurementId = '';
      if(mapInstance) {
        mapInstance.closePopup();
      }
    }
    renderSavedPointsList();
    persistSavedPointsState();
  }

  function toggleMeasurementVisibility(measurementId) {
    const measurement = findMeasurement(measurementId);
    if(!measurement) {
      return;
    }
    if(!mapInstance) {
      measurement.visible = !measurement.visible;
      if(!measurement.visible && activeMeasurementId === measurementId) {
        activeMeasurementId = '';
      }
      renderSavedPointsList();
      persistSavedPointsState();
      return;
    }
    if(measurement.visible) {
      if(measurement.polyline) {
        mapInstance.removeLayer(measurement.polyline);
      }
      measurement.visible = false;
      if(activeMeasurementId === measurementId) {
        activeMeasurementId = '';
        mapInstance.closePopup();
      }
    } else {
      measurement.visible = true;
      createPolylineForMeasurement(measurement);
    }
    renderSavedPointsList();
    persistSavedPointsState();
  }

  function focusMeasurement(measurementId, { openPopup = false, skipRender = false, pan = true } = {}) {
    const measurement = findMeasurement(measurementId);
    if(!measurement) {
      return;
    }
    activeMeasurementId = measurementId;
    activeSavedPointId = '';
    if(!mapInstance) {
      if(!skipRender) {
        renderSavedPointsList();
      }
      return;
    }
    if(!measurement.polyline || !mapInstance.hasLayer(measurement.polyline)) {
      createPolylineForMeasurement(measurement);
    }
    measurement.visible = true;
    const polyline = measurement.polyline;
    if(polyline) {
      const bounds = polyline.getBounds();
      if(pan && bounds.isValid()) {
        mapInstance.fitBounds(bounds, { padding: [28, 28], maxZoom: 18 });
      }
      if(openPopup) {
        polyline.openPopup();
      }
    }
    if(!skipRender) {
      renderSavedPointsList();
    }
  }

  function renameMeasurement(measurementId) {
    const measurement = findMeasurement(measurementId);
    if(!measurement) {
      return;
    }
    const nextName = window.prompt('أدخل اسم المسافة الجديد:', measurement.name);
    if(nextName === null) {
      return;
    }
    const trimmed = nextName.trim();
    if(!trimmed) {
      alert('الاسم لا يمكن أن يكون فارغًا.');
      return;
    }
    measurement.name = trimmed;
    updateMeasurementPopup(measurement);
    renderSavedPointsList();
    persistSavedPointsState();
  }

  function editMeasurementEndpoint(measurementId, endpointKey) {
    const measurement = findMeasurement(measurementId);
    if(!measurement || (endpointKey !== 'pointA' && endpointKey !== 'pointB')) {
      return;
    }
    cancelMeasurementSelection();
    setManualPointSelectionState(false);
    measurementSelectionState = {
      mode: 'edit',
      stage: 'awaiting-edit-point',
      measurementId,
      endpointKey,
      pointA: null
    };
    setDistanceSelectionMode(true);
    clearMeasurementSelectionMarkers();
    setMeasurementSelectionMarker('pointA', measurement.pointA);
    setMeasurementSelectionMarker('pointB', measurement.pointB);
    updateMeasurementSelectionPrompt();
  }

  function applyMeasurementEndpointUpdate(measurementId, endpointKey, endpoint) {
    const measurement = findMeasurement(measurementId);
    if(!measurement || !endpoint || (endpointKey !== 'pointA' && endpointKey !== 'pointB')) {
      return null;
    }
    measurement[endpointKey] = endpoint;
    if(mapInstance) {
      createPolylineForMeasurement(measurement);
    }
    renderSavedPointsList();
    persistSavedPointsState();
    return endpointKey === 'pointA' ? 'النقطة A' : 'النقطة B';
  }

  function startDistanceFromPoint(pointId) {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    const point = findSavedPoint(pointId);
    if(!point) {
      alert('تعذر العثور على هذه النقطة.');
      return;
    }
    cancelMeasurementSelection();
    setManualPointSelectionState(false);
    measurementSelectionState = {
      mode: 'create',
      stage: 'awaiting-second-point',
      pointA: createMeasurementEndpoint(point.lat, point.lon, point.id)
    };
    setDistanceSelectionMode(true);
    clearMeasurementSelectionMarkers();
    setMeasurementSelectionMarker('pointA', measurementSelectionState.pointA);
    setMeasurementSelectionMarker('pointB', null);
    updateMeasurementSelectionPrompt();
  }

  function startDistanceFromMenu() {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    cancelMeasurementSelection();
    setManualPointSelectionState(false);
    measurementSelectionState = {
      mode: 'create',
      stage: 'awaiting-first-point',
      pointA: null
    };
    setDistanceSelectionMode(true);
    clearMeasurementSelectionMarkers();
    updateMeasurementSelectionPrompt();
  }

  function cancelMeasurementSelection(showNotice = false) {
    const wasActive = Boolean(measurementSelectionState);
    measurementSelectionState = null;
    clearMeasurementSelectionMarkers();
    setDistanceSelectionMode(false);
    clearMapStatusMessage();
    if(showNotice && wasActive) {
      setMapStatusMessage('تم إلغاء اختيار المسافة.', { persistent: false });
    }
  }

  function updateMeasurementSelectionPrompt() {
    if(!measurementSelectionState) {
      clearMapStatusMessage();
      return;
    }
    let message = 'اختر نقطة أخرى على الخريطة';
    if(measurementSelectionState.stage === 'awaiting-first-point') {
      message = 'اختر نقطة البداية على الخريطة';
    } else if(measurementSelectionState.stage === 'awaiting-edit-point') {
      message = measurementSelectionState.endpointKey === 'pointA'
        ? 'اختر موقعًا جديدًا للنقطة A'
        : 'اختر موقعًا جديدًا للنقطة B';
    }
    setMapStatusMessage(message, { persistent: true });
  }

  function finalizeMeasurementCreation(pointB) {
    if(!measurementSelectionState || !measurementSelectionState.pointA || !pointB) {
      cancelMeasurementSelection();
      return;
    }
    addMeasurement(measurementSelectionState.pointA, pointB);
    cancelMeasurementSelection();
    setMapStatusMessage('تم إنشاء المسافة بنجاح.', { persistent: false });
  }

  function handleMeasurementPointSelection(lat, lon, { refPointId = null } = {}) {
    if(!measurementSelectionState) {
      return false;
    }
    const endpoint = createMeasurementEndpoint(lat, lon, refPointId);
    if(!endpoint) {
      return true;
    }
    if(measurementSelectionState.stage === 'awaiting-first-point') {
      measurementSelectionState.pointA = endpoint;
      measurementSelectionState.stage = 'awaiting-second-point';
      setMeasurementSelectionMarker('pointA', endpoint);
      setMeasurementSelectionMarker('pointB', null);
      updateMeasurementSelectionPrompt();
      return true;
    }
    if(measurementSelectionState.stage === 'awaiting-second-point') {
      if(!measurementSelectionState.pointA) {
        measurementSelectionState.pointA = endpoint;
        setMeasurementSelectionMarker('pointA', endpoint);
        setMeasurementSelectionMarker('pointB', null);
        updateMeasurementSelectionPrompt();
        return true;
      }
      setMeasurementSelectionMarker('pointB', endpoint);
      finalizeMeasurementCreation(endpoint);
      return true;
    }
    if(measurementSelectionState.stage === 'awaiting-edit-point') {
      setMeasurementSelectionMarker(measurementSelectionState.endpointKey, endpoint);
      const label = applyMeasurementEndpointUpdate(measurementSelectionState.measurementId, measurementSelectionState.endpointKey, endpoint);
      cancelMeasurementSelection();
      if(label) {
        setMapStatusMessage(`تم تحديث ${label}.`, { persistent: false });
      }
      return true;
    }
    return false;
  }

  function toggleAllSavedPointsVisibility() {
    const { total, visible } = getSavedPointsVisibilityStats();
    if(total === 0) {
      return;
    }
    const shouldShow = visible === 0;
    savedManualPoints.forEach((point) => {
      if(!point.marker || !mapInstance) {
        point.visible = shouldShow;
        return;
      }
      if(shouldShow) {
        if(!point.visible) {
          point.marker.addTo(mapInstance);
          point.visible = true;
          updateSavedPointPopup(point);
        }
      } else if(point.visible) {
        mapInstance.removeLayer(point.marker);
        point.visible = false;
      }
    });
    if(!shouldShow) {
      activeSavedPointId = '';
      activeMeasurementId = '';
      if(mapInstance) {
        mapInstance.closePopup();
      }
    }
    savedMeasurements.forEach((measurement) => {
      if(!mapInstance) {
        measurement.visible = shouldShow;
        return;
      }
      if(shouldShow) {
        if(!measurement.visible) {
          measurement.visible = true;
          if(!measurement.polyline) {
            createPolylineForMeasurement(measurement);
          } else {
            measurement.polyline.addTo(mapInstance);
            updateMeasurementPopup(measurement);
          }
        }
      } else if(measurement.visible) {
        if(measurement.polyline) {
          mapInstance.removeLayer(measurement.polyline);
        }
        measurement.visible = false;
      }
    });
    renderSavedPointsList();
    persistSavedPointsState();
  }

  function toggleSavedPointVisibility(pointId) {
    const point = findSavedPoint(pointId);
    if(!point || !mapInstance || !point.marker) {
      return;
    }
    if(point.visible) {
      mapInstance.removeLayer(point.marker);
      mapInstance.closePopup();
      point.visible = false;
      if(activeSavedPointId === pointId) {
        activeSavedPointId = '';
      }
    } else {
      point.marker.addTo(mapInstance);
      point.visible = true;
    }
    updateSavedPointPopup(point);
    renderSavedPointsList();
    persistSavedPointsState();
  }

  function focusSavedPoint(pointId, { openPopup = false, zoom = 15, skipRender = false, pan = true } = {}) {
    const point = findSavedPoint(pointId);
    if(!point || !mapInstance) {
      return;
    }
    if(!point.visible) {
      point.marker.addTo(mapInstance);
      point.visible = true;
      updateSavedPointPopup(point);
      persistSavedPointsState();
    }
    if(pan) {
      mapInstance.setView([point.lat, point.lon], zoom);
    }
    activeSavedPointId = pointId;
    activeMeasurementId = '';
    if(openPopup && point.marker) {
      point.marker.openPopup();
    }
    if(!skipRender) {
      renderSavedPointsList();
    }
  }

  function renameSavedPoint(pointId) {
    const point = findSavedPoint(pointId);
    if(!point) {
      return;
    }
    const nextName = window.prompt('أدخل اسم النقطة الجديد:', point.name);
    if(nextName === null) {
      return;
    }
    const trimmed = nextName.trim();
    if(!trimmed) {
      alert('الاسم لا يمكن أن يكون فارغًا.');
      return;
    }
    point.name = trimmed;
    updateSavedPointPopup(point);
    renderSavedPointsList();
    persistSavedPointsState();
  }

  function removeSavedPoint(pointId) {
    const index = savedManualPoints.findIndex((point) => point.id === pointId);
    if(index === -1) {
      return;
    }
    const [removedPoint] = savedManualPoints.splice(index, 1);
    if(removedPoint && removedPoint.marker && mapInstance) {
      mapInstance.removeLayer(removedPoint.marker);
    }
    if(activeSavedPointId === pointId) {
      activeSavedPointId = '';
    }
    if(mapInstance) {
      mapInstance.closePopup();
    }
    renderSavedPointsList();
    persistSavedPointsState();
  }

  function locateUser() {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    if(!navigator.geolocation) {
      alert('GPS غير مدعوم في هذا المتصفح');
      return;
    }

    stopGeoWatch();
    coarseLocationWarned = false;
    const geoOptions = {
      enableHighAccuracy: true,
      timeout: 15000,
      maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy === null || accuracy > 120) {
          startGeoWatch(geoOptions);
        }
      },
      (error) => {
        handleUserLocationError(error);
      },
      geoOptions
    );
  }

  function handleUserLocationSuccess(position) {
    const latitude = position.coords.latitude;
    const longitude = position.coords.longitude;
    const accuracy = Number.isFinite(position.coords.accuracy) ? Math.round(position.coords.accuracy) : null;
    const latDmsText = formatDMS(decimalToDMS(latitude, true));
    const lonDmsText = formatDMS(decimalToDMS(longitude, false));
    const popupHeader = accuracy !== null
      ? `Ma position actuelle (±${accuracy} m)`
      : 'Ma position actuelle';
    const popupText = `${popupHeader}<br>${wrapDmsHtml(latDmsText, lonDmsText)}`;

    updateUserLocationMarker(latitude, longitude, popupText, 16);

    if(accuracy !== null && Number.isFinite(accuracy)) {
      const circleTarget = [latitude, longitude];
      if(!userAccuracyCircle) {
        userAccuracyCircle = L.circle(circleTarget, {
          radius: accuracy,
          color: '#1fa86d',
          fillColor: '#1fa86d',
          fillOpacity: 0.15,
          weight: 1
        }).addTo(mapInstance);
      } else {
        userAccuracyCircle.setLatLng(circleTarget);
        userAccuracyCircle.setRadius(accuracy);
      }
    } else if(userAccuracyCircle) {
      mapInstance.removeLayer(userAccuracyCircle);
      userAccuracyCircle = null;
    }

    if(accuracy !== null && accuracy > 10000 && !coarseLocationWarned) {
      alert('تم الحصول على موقع تقريبي فقط. الرجاء تفعيل GPS أو الاتصال بشبكة Wi-Fi للحصول على دقة أعلى.');
      coarseLocationWarned = true;
    }

    return accuracy;
  }

  function handleUserLocationError(error) {
    stopGeoWatch();
    if(error && error.code === error.PERMISSION_DENIED) {
      alert('تم رفض إذن الموقع');
      return;
    }
    if(error && error.code === error.POSITION_UNAVAILABLE) {
      alert('تعذر تحديد موقعك. تأكد من تفعيل GPS أو خدمات الموقع ثم أعد المحاولة.');
      return;
    }
    if(error && error.code === error.TIMEOUT) {
      alert('انتهت مهلة الحصول على الموقع. حاول مرة أخرى بعد التأكد من تفعيل GPS.');
      return;
    }
    alert('تعذر الحصول على الموقع الحالي');
  }

  function startGeoWatch(options) {
    if(typeof navigator.geolocation.watchPosition !== 'function') {
      return;
    }
    stopGeoWatch();
    geoWatchId = navigator.geolocation.watchPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy !== null && accuracy <= 60) {
          stopGeoWatch();
        }
      },
      (error) => {
        stopGeoWatch();
        handleUserLocationError(error);
      },
      options
    );

    geoWatchTimeoutId = window.setTimeout(() => {
      stopGeoWatch();
    }, 20000);
  }

  function stopGeoWatch() {
    if(geoWatchId !== null) {
      navigator.geolocation.clearWatch(geoWatchId);
      geoWatchId = null;
    }
    if(geoWatchTimeoutId) {
      clearTimeout(geoWatchTimeoutId);
      geoWatchTimeoutId = null;
    }
  }

  function updateFileHint() {
    const type = document.getElementById('conversionType').value;
    const hint = document.getElementById('fileHint');
    const manualHint = document.getElementById('manualHint');
    const csvImage = document.getElementById('csvModelImage');
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const batchSection = document.getElementById('batchSection');
    toggleManualFields(type);

    if(type === 'latlong-to-Merchich') {
      const disabledMsg = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S''). الرجاء استخدام التحويل اليدوي لهذا الاتجاه.";
      if(hint) {
        hint.dataset.defaultMessage = disabledMsg;
        hint.innerText = disabledMsg;
      }
      manualHint.innerText = "أدخل خطوط الطول والعرض (D°M'S'') ليتم تحويلها إلى إحداثيات X و Y باستخدام المنطقة المناسبة.";
      if(batchSection) batchSection.style.display = 'none';
      if(csvImage) {
        csvImage.style.display = 'none';
      }
      if(fileInput) {
        fileInput.value = '';
        fileInput.disabled = true;
      }
      if(convertBtn) convertBtn.disabled = true;
      if(downloadBtn) downloadBtn.disabled = true;
      lastConvertedRows = [];
      lastConvertedFields = null;
    } else {
      const activeMsg = "ارفع ملف CSV (أعمدة X و Y) بحجم لا يتجاوز 1 ميغابايت وبعدد أسطر لا يتخطى 200 ليتم تحويله إلى Lat/Long (D°M'S'').";
      if(hint) {
        hint.dataset.defaultMessage = activeMsg;
        hint.innerText = activeMsg;
      }
      manualHint.innerText = "أدخل إحداثيات (X, Y) يدويًا ليتم تحويلها مباشرة إلى Lat/Long باستخدام المنطقة المناسبة.";
      if(batchSection) batchSection.style.display = 'block';
      if(csvImage) {
        csvImage.src = 'modelcsvxy.JPG';
        csvImage.style.display = 'block';
      }
      if(fileInput) fileInput.disabled = false;
      updateConvertButtonState();
    }
  }

  function toggleManualFields(type) {
    const dmsFields = document.getElementById('dmsFields');
    const cartesianFields = document.getElementById('cartesianFields');
    if(type === "latlong-to-Merchich") {
      dmsFields.style.display = 'flex';
      cartesianFields.style.display = 'none';
    } else {
      dmsFields.style.display = 'none';
      cartesianFields.style.display = 'flex';
    }
  }

  function dmsToDecimal(deg, min, sec, hemisphere) {
    if(isNaN(deg) || isNaN(min) || isNaN(sec)) {
      return NaN;
    }
    const absValue = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const hemisphereSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    const degreeSign = deg < 0 ? -1 : 1;
    return absValue * hemisphereSign * degreeSign;
  }

  function decimalToDMS(value, isLatitude) {
    if(isNaN(value)) return null;
    const absValue = Math.abs(value);
    const degrees = Math.floor(absValue);
    const minutesFloat = (absValue - degrees) * 60;
    const minutes = Math.floor(minutesFloat);
    const seconds = (minutesFloat - minutes) * 60;
    const hemisphere = isLatitude
      ? (value < 0 ? 'S' : 'N')
      : (value < 0 ? 'W' : 'E');
    return { degrees, minutes, seconds, hemisphere, isLatitude };
  }

  function padTwoDigits(value) {
    return value < 10 ? `0${value}` : `${value}`;
  }

  function padSeconds(seconds) {
    const str = seconds.toFixed(2);
    return seconds < 10 ? `0${str}` : str;
  }

  function setDmsInputsFromDecimal(latitude, longitude) {
    const latDms = decimalToDMS(latitude, true);
    const lonDms = decimalToDMS(longitude, false);
    applyDmsToInputs('lat', latDms);
    applyDmsToInputs('lon', lonDms);
    setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
    validateGeographicInputs();
  }

  function applyDmsToInputs(prefix, dms) {
    if(!dms) {
      return;
    }
    const degreeInput = document.getElementById(`${prefix}Deg`);
    if(degreeInput) {
      degreeInput.value = padTwoDigits(dms.degrees);
    }
    const minuteInput = document.getElementById(`${prefix}Min`);
    if(minuteInput) {
      minuteInput.value = padTwoDigits(dms.minutes);
    }
    const secondInput = document.getElementById(`${prefix}Sec`);
    if(secondInput) {
      secondInput.value = padSeconds(dms.seconds);
    }
    const hemisphereSelect = document.getElementById(`${prefix}Hemisphere`);
    if(hemisphereSelect) {
      hemisphereSelect.value = dms.hemisphere;
    }
  }

  function enforceNumericCharacters(input, options = {}) {
    if(!input) {
      return '';
    }
    const {
      allowDecimal = false,
      allowNegative = false,
      maxLength = null,
      decimalSeparatorReplacement = null
    } = options;
    const rawValue = input.value || '';
    let sanitized = '';
    let decimalUsed = false;
    let decimalChar = null;

    for(let index = 0; index < rawValue.length; index++) {
      const char = rawValue[index];
      if(char >= '0' && char <= '9') {
        sanitized += char;
        continue;
      }
      if(allowDecimal && (char === '.' || char === ',')) {
        if(decimalUsed) {
          continue;
        }
        sanitized += char;
        decimalUsed = true;
        decimalChar = char;
        continue;
      }
      if(allowNegative && char === '-' && sanitized.length === 0) {
        sanitized = '-';
      }
    }

    if(!allowNegative) {
      sanitized = sanitized.replace(/-/g, '');
    } else if(sanitized.indexOf('-') > 0) {
      sanitized = sanitized.replace(/-/g, '');
      sanitized = `-${sanitized}`;
    }

    if(typeof maxLength === 'number' && maxLength > 0 && !allowDecimal) {
      const isNegative = allowNegative && sanitized.startsWith('-');
      const limit = maxLength + (isNegative ? 1 : 0);
      sanitized = sanitized.slice(0, limit);
    }

    if(!allowDecimal) {
      sanitized = sanitized.replace(/[.,]/g, '');
    } else if(decimalSeparatorReplacement && decimalChar && decimalChar !== decimalSeparatorReplacement) {
      const decimalIndex = sanitized.indexOf(decimalChar);
      if(decimalIndex !== -1) {
        sanitized = sanitized.slice(0, decimalIndex) + decimalSeparatorReplacement + sanitized.slice(decimalIndex + 1);
      }
    }

    if(input.value !== sanitized) {
      input.value = sanitized;
    }
    return sanitized;
  }

  function enforceTwoDigits(input) {
    enforceNumericCharacters(input, { maxLength: 2 });
  }

  function sanitizeSeconds(input) {
    enforceNumericCharacters(input, { allowDecimal: true });
  }

  function finalizeSeconds(input) {
    let value = input.value.trim();
    if(value === '') return;
    const usesComma = value.includes(',');
    const usesDot = value.includes('.');
    const normalized = value.replace(',', '.');
    let num = parseFloat(normalized);
    if(isNaN(num)) {
      input.value = '';
      return;
    }
    num = Math.min(59.99, Math.max(0, num));
    if(usesComma || usesDot) {
      const truncated = Math.floor(num * 100) / 100;
      let str = truncated.toFixed(2);
      if(usesComma && !usesDot) {
        str = str.replace('.', ',');
      }
      input.value = str;
    } else {
      input.value = Math.round(num).toString();
    }
  }

  function readSecondsValue(elementId) {
    const raw = document.getElementById(elementId).value.trim();
    if(raw === '') return NaN;
    const normalized = raw.replace(',', '.');
    const num = parseFloat(normalized);
    if(isNaN(num)) return NaN;
    const clamped = Math.min(59.99, Math.max(0, num));
    return Math.floor(clamped * 100) / 100;
  }

  function areInputsFilled(inputIds) {
    return inputIds.every((id) => {
      const element = document.getElementById(id);
      return element && element.value.trim() !== '';
    });
  }

  function setInputsValidity(inputIds, { reset = false, isValid = true, message = '' } = {}) {
    inputIds.forEach((id) => {
      const element = document.getElementById(id);
      if(!element) {
        return;
      }
      if(reset) {
        element.classList.remove('is-invalid');
        element.removeAttribute('aria-invalid');
        element.removeAttribute('title');
        return;
      }
      if(isValid) {
        element.classList.remove('is-invalid');
        element.removeAttribute('aria-invalid');
        element.removeAttribute('title');
        return;
      }
      element.classList.add('is-invalid');
      element.setAttribute('aria-invalid', 'true');
      if(message) {
        element.setAttribute('title', message);
      } else {
        element.removeAttribute('title');
      }
    });
  }

  function getZoneKeyForLatitude(latitude) {
    if(!Number.isFinite(latitude)) {
      return null;
    }
    for(const [zoneKey, limits] of Object.entries(zoneValidationLimits)) {
      const range = limits.latRange;
      if(range && latitude >= range.min && latitude <= range.max) {
        return zoneKey;
      }
    }
    return null;
  }

  function isPointInsideMorocco(longitude, latitude) {
    const geometry = MOROCCO_BOUNDARY.geometry || MOROCCO_BOUNDARY;
    if(!geometry || !geometry.coordinates) {
      return false;
    }
    const polygons = geometry.type === 'MultiPolygon'
      ? geometry.coordinates
      : [geometry.coordinates];
    for(const polygon of polygons) {
      if(isPointInsidePolygonRings(longitude, latitude, polygon)) {
        return true;
      }
    }
    return false;
  }

  function isPointInsidePolygonRings(longitude, latitude, rings) {
    if(!Array.isArray(rings) || !rings.length) {
      return false;
    }
    if(!isPointInRing(longitude, latitude, rings[0])) {
      return false;
    }
    for(let i = 1; i < rings.length; i++) {
      if(isPointInRing(longitude, latitude, rings[i])) {
        return false;
      }
    }
    return true;
  }

  function isPointInRing(longitude, latitude, ring) {
    if(!Array.isArray(ring) || ring.length < 4) {
      return false;
    }
    let inside = false;
    for(let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      const xi = ring[i][0];
      const yi = ring[i][1];
      const xj = ring[j][0];
      const yj = ring[j][1];
      const intersects = ((yi > latitude) !== (yj > latitude))
        && (longitude < (xj - xi) * (latitude - yi) / ((yj - yi) || 1e-12) + xi);
      if(intersects) {
        inside = !inside;
      }
    }
    return inside;
  }

  function getDomainErrorMessage(errorType) {
    if(errorType === 'morocco') {
      return MOROCCO_DOMAIN_ERROR_TEXT;
    }
    if(errorType === 'zones') {
      return ZONE_RANGE_ERROR_TEXT;
    }
    return 'تعذر تحديد المجال الجغرافي للنقطة.';
  }

  function formatZoneMismatchMessage(actualZoneKey, selectedZoneKey) {
    const actualLabel = getZoneDisplayLabel(actualZoneKey) || actualZoneKey || 'منطقة غير معروفة';
    const selectedLabel = getZoneDisplayLabel(selectedZoneKey) || selectedZoneKey || 'منطقة غير محددة';
    return ZONE_MISMATCH_WARNING_TEMPLATE
      .replace('{actualZone}', actualLabel)
      .replace('{selectedZone}', selectedLabel);
  }

  function resolveZoneAlignment(actualZoneKey, { requireConfirmation = true } = {}) {
    if(!actualZoneKey) {
      return { proceed: false, zoneKey: null, warning: null };
    }

    const hasUserPreference = Boolean(selectedCityName);
    const updateActiveZone = () => {
      setActiveZone(actualZoneKey);
      updateCityZoneBadge(getZoneDisplayLabel(actualZoneKey));
    };

    if(!hasUserPreference) {
      if(currentZoneKey !== actualZoneKey) {
        updateActiveZone();
      }
      return { proceed: true, zoneKey: actualZoneKey, warning: null };
    }

    if(currentZoneKey === actualZoneKey) {
      updateActiveZone();
      return { proceed: true, zoneKey: actualZoneKey, warning: null };
    }

    const warning = formatZoneMismatchMessage(actualZoneKey, currentZoneKey);
    if(!requireConfirmation) {
      return { proceed: true, zoneKey: actualZoneKey, warning };
    }

    const actualLabel = getZoneDisplayLabel(actualZoneKey) || actualZoneKey;
    const confirmMessage = `${warning}\nهل تريد المتابعة باستخدام ${actualLabel}؟`;
    const accepted = typeof window !== 'undefined'
      && typeof window.confirm === 'function'
        ? window.confirm(confirmMessage)
        : true;
    if(!accepted) {
      return { proceed: false, zoneKey: null, warning };
    }
    updateActiveZone();
    return { proceed: true, zoneKey: actualZoneKey, warning };
  }

  function convertPlanarToWgs84Auto(x, y) {
    let fallbackReason = null;
    let fallbackCandidate = null;
    for(const [zoneKey, zoneConfig] of Object.entries(merchichZones)) {
      if(!zoneConfig || !zoneConfig.proj) {
        continue;
      }
      let lon;
      let lat;
      try {
        [lon, lat] = proj4(zoneConfig.proj, wgs84, [x, y]);
      } catch (error) {
        continue;
      }
      if(!Number.isFinite(lat) || !Number.isFinite(lon)) {
        continue;
      }
      if(!isPointInsideMorocco(lon, lat)) {
        fallbackReason = fallbackReason || 'morocco';
        continue;
      }
      const inferredZoneKey = getZoneKeyForLatitude(lat);
      if(!inferredZoneKey) {
        fallbackReason = fallbackReason || 'zones';
        continue;
      }
      const candidate = {
        status: 'ok',
        lon,
        lat,
        inferredZoneKey,
        sourceZoneKey: zoneKey
      };
      if(inferredZoneKey === zoneKey) {
        return candidate;
      }
      if(!fallbackCandidate) {
        fallbackCandidate = candidate;
      }
    }
    if(fallbackCandidate) {
      return fallbackCandidate;
    }
    return { status: 'error', errorType: fallbackReason || 'invalid' };
  }

  function getDmsDecimal(prefix) {
    const deg = parseFloat(document.getElementById(`${prefix}Deg`).value);
    const min = parseFloat(document.getElementById(`${prefix}Min`).value);
    const sec = readSecondsValue(`${prefix}Sec`);
    const hemisphereElement = document.getElementById(`${prefix}Hemisphere`);
    const hemisphere = hemisphereElement ? hemisphereElement.value : (prefix === 'lat' ? 'N' : 'E');
    return dmsToDecimal(deg, min, sec, hemisphere);
  }

  function validateGeographicInputs() {
    const conversionType = document.getElementById('conversionType').value;
    if(conversionType !== 'latlong-to-Merchich') {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'skipped' };
    }

    if(!areInputsFilled(GEO_COORD_INPUT_IDS)) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'incomplete' };
    }

    const latValue = getDmsDecimal('lat');
    const lonValue = getDmsDecimal('lon');
    if(!Number.isFinite(latValue) || !Number.isFinite(lonValue)) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'invalid-input' };
    }

    setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
    return { status: 'validated', latValue, lonValue };
  }

  function resetPlanarValidity() {
    setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
  }

  function validateAllCoordinateGroups() {
    validateGeographicInputs();
    resetPlanarValidity();
  }

  function formatDMS(dms) {
    if(!dms) return '';
    const degreeWidth = dms.isLatitude ? 2 : 3;
    const degreeStr = dms.degrees.toString().padStart(degreeWidth, '0');
    const minuteStr = padTwoDigits(dms.minutes);
    const secondStr = padSeconds(dms.seconds);
    return `${degreeStr}° ${minuteStr}' ${secondStr}" ${dms.hemisphere}`;
  }

  function wrapDmsHtml(latText, lonText) {
    const safeLat = latText || '';
    const safeLon = lonText || '';
    return `<span class="dms-popup">${safeLat}<br>${safeLon}</span>`;
  }

  function normalizeDmsString(value) {
    return value.toString()
      .replace(/,/g, '.')
      .replace(/″|”|“/g, '"')
      .replace(/′|’|`/g, "'")
      .replace(/º|˚/g, '°')
      .trim();
  }

  function parseCsvDms(value, hemisphere) {
    if(value === undefined || value === null) return NaN;
    const normalized = normalizeDmsString(value);
    const cleaned = normalized
      .replace(/[NSEW]\s*$/i, '')
      .replace(/"/g, '')
      .trim();
    const regex = /(-?\d+(?:\.\d+)?)\s*°\s*(\d+(?:\.\d+)?)\s*['′’]\s*(\d+(?:\.\d+)?)/;
    const match = cleaned.match(regex);
    if(!match) return NaN;
    const deg = parseFloat(match[1]);
    const min = parseFloat(match[2]);
    const sec = parseFloat(match[3]);
    const base = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const degreeSign = deg < 0 ? -1 : 1;
    const hemiSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    return base * degreeSign * hemiSign;
  }

  function getCsvField(row, targetKey) {
    const normalizedTarget = normalizeKeyName(targetKey);
    for (const key in row) {
      if(!Object.prototype.hasOwnProperty.call(row, key)) continue;
      if(typeof key !== 'string') continue;
      if(normalizeKeyName(key) === normalizedTarget) {
        return row[key];
      }
    }
    return undefined;
  }

  function hasField(fields, targetKey) {
    if(!Array.isArray(fields)) return false;
    const normalizedKey = normalizeKeyName(targetKey);
    return fields.some(field => {
      if(field === undefined || field === null) return false;
      return normalizeKeyName(field) === normalizedKey;
    });
  }

  function normalizeKeyName(key) {
    if(key === undefined || key === null) return '';
    return key.toString().replace(/\ufeff/g, '').trim().toLowerCase();
  }

  function updateConvertButtonState() {
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const type = document.getElementById('conversionType').value;
    if(!convertBtn || !fileInput) return;
    if(type !== 'Merchich-to-latlong') {
      convertBtn.disabled = true;
      return;
    }
    const file = fileInput.files[0];
    const isValidSize = file ? file.size <= MAX_FILE_SIZE_BYTES : false;
    convertBtn.disabled = !isValidSize;
  }

  function handleCsvFileChange() {
    const fileInput = document.getElementById('csvFile');
    const hint = document.getElementById('fileHint');
    if(!fileInput) return;
    const file = fileInput.files[0];
    if(file && file.size > MAX_FILE_SIZE_BYTES) {
      const sizeMb = (file.size / (1024 * 1024)).toFixed(2);
      if(hint) {
        hint.innerText = `حجم الملف ${sizeMb} ميغابايت وهو أكبر من الحد المسموح (1 ميغابايت). اختر ملفًا أصغر ثم أعد المحاولة.`;
      }
      fileInput.value = '';
    } else if(hint && hint.dataset.defaultMessage) {
      hint.innerText = hint.dataset.defaultMessage;
    }

    updateConvertButtonState();
    lastConvertedRows = [];
    lastConvertedFields = null;
    const downloadBtn = document.getElementById('downloadBtn');
    if(downloadBtn) downloadBtn.disabled = true;
  }

  function normalizeZoneKey(zoneValue) {
    if(typeof zoneValue !== 'string') {
      return '';
    }
    return zoneValue
      .trim()
      .replace(/\s+/g, '_')
      .replace(/-+/g, '_')
      .replace(/zone/gi, 'Zone');
  }

  function getZoneDisplayLabel(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    const zoneConfig = merchichZones[normalized];
    if(zoneConfig && zoneConfig.label) {
      return zoneConfig.label;
    }
    return normalized ? normalized.replace(/_/g, ' ') : '';
  }

  function getCurrentZoneConfig() {
    return merchichZones[currentZoneKey] || merchichZones[defaultZoneKey] || null;
  }

  function setActiveZone(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    if(normalized && merchichZones[normalized]) {
      currentZoneKey = normalized;
    } else {
      currentZoneKey = defaultZoneKey;
    }
  }

  function initManualNumericFields() {
    const manualNumericInputs = [
      { id: 'manualX', options: { allowDecimal: true, decimalSeparatorReplacement: '.' } },
      { id: 'manualY', options: { allowDecimal: true, decimalSeparatorReplacement: '.' } }
    ];

    manualNumericInputs.forEach(({ id, options }) => {
      const element = document.getElementById(id);
      if(!element) {
        return;
      }
      const handler = () => {
        enforceNumericCharacters(element, options);
        resetPlanarValidity();
      };
      element.addEventListener('input', handler);
      element.addEventListener('blur', handler);
    });
  }

  function initDmsValidationListeners() {
    const registerGroup = (ids, callback) => {
      ids.forEach((id) => {
        const element = document.getElementById(id);
        if(!element) {
          return;
        }
        element.addEventListener('input', callback);
        element.addEventListener('blur', callback);
      });
    };
    registerGroup(LAT_INPUT_IDS, () => validateGeographicInputs());
    registerGroup(LON_INPUT_IDS, () => validateGeographicInputs());
    const latHem = document.getElementById('latHemisphere');
    if(latHem) {
      latHem.addEventListener('change', () => validateGeographicInputs());
    }
    const lonHem = document.getElementById('lonHemisphere');
    if(lonHem) {
      lonHem.addEventListener('change', () => validateGeographicInputs());
    }
  }


  function flattenCityZones(cityData) {
    const flattened = {};
    if(!cityData || typeof cityData !== 'object') {
      return flattened;
    }
    Object.entries(cityData).forEach(([key, value]) => {
      if(Array.isArray(value)) {
        const zoneKey = normalizeZoneKey(key);
        if(!zoneKey) {
          return;
        }
        value.forEach((cityName) => {
          if(typeof cityName !== 'string') {
            return;
          }
          const trimmed = cityName.trim();
          if(!trimmed) {
            return;
          }
          flattened[trimmed] = zoneKey;
        });
        return;
      }
      if(typeof value === 'string') {
        const zoneKey = normalizeZoneKey(value);
        if(!zoneKey) {
          return;
        }
        const trimmedKey = typeof key === 'string' ? key.trim() : key;
        if(!trimmedKey) {
          return;
        }
        flattened[trimmedKey] = zoneKey;
      }
    });
    return flattened;
  }

  function getCityDisplayLabel(name) {
    if(!name) {
      return '';
    }
    const match = cityOptionsCache.find((entry) => entry.name === name);
    return match ? match.display : '';
  }

  function getCityEntryByName(name) {
    if(!name) {
      return null;
    }
    return cityOptionsCache.find((entry) => entry.name === name) || null;
  }

  function clearSelectedCityState() {
    selectedCityName = '';
    setActiveZone('');
    updateCityZoneBadge('');
    validateAllCoordinateGroups();
  }

  function commitCitySelection(entry) {
    if(!entry) {
      clearSelectedCityState();
      hideCitySuggestionsList();
      return;
    }
    selectedCityName = entry.name;
    const normalizedZone = normalizeZoneKey(entry.zoneKey);
    const zoneLabel = normalizedZone ? getZoneDisplayLabel(normalizedZone) : '';
    setActiveZone(normalizedZone);
    updateCityZoneBadge(zoneLabel);
    const searchInput = document.getElementById('citySearchInput');
    if(searchInput) {
      const displayValue = entry.display || entry.name;
      searchInput.value = displayValue;
      if(typeof searchInput.setSelectionRange === 'function') {
        const cursorPos = displayValue.length;
        searchInput.setSelectionRange(cursorPos, cursorPos);
      }
    }
    hideCitySuggestionsList();
    validateAllCoordinateGroups();
    syncCityClearButtonVisibility();
  }

  function updateCitySearchInputUI({ disabled = false, placeholderText } = {}) {
    const searchInput = document.getElementById('citySearchInput');
    if(!searchInput) {
      return;
    }
    const placeholder = placeholderText || (disabled ? 'قائمة المدن غير متاحة' : 'ابحث عن المدينة');
    searchInput.placeholder = placeholder;
    if(disabled) {
      searchInput.value = '';
      searchInput.setAttribute('disabled', 'true');
      syncCityClearButtonVisibility();
      return;
    }
    searchInput.removeAttribute('disabled');
    if(selectedCityName && !searchInput.matches(':focus')) {
      const label = getCityDisplayLabel(selectedCityName) || selectedCityName;
      searchInput.value = label;
    }
    syncCityClearButtonVisibility();
  }

  // Restrict city search input to alphabetic characters and spaces
  function sanitizeCitySearchValueWithCaret(value, caretPosition) {
    if(typeof value !== 'string') {
      return { sanitizedValue: '', nextCaret: 0 };
    }
    let sanitizedValue = '';
    let nextCaret = typeof caretPosition === 'number' ? caretPosition : value.length;
    for(let index = 0; index < value.length; index++) {
      const char = value[index];
      if(CITY_ALLOWED_CHAR_REGEX.test(char)) {
        sanitizedValue += char;
      } else if(index < nextCaret) {
        nextCaret--;
      }
    }
    nextCaret = Math.max(0, Math.min(nextCaret, sanitizedValue.length));
    return { sanitizedValue, nextCaret };
  }

  function enforceCitySearchAlphaOnly(inputElement) {
    if(!inputElement) {
      return '';
    }
    const rawValue = inputElement.value || '';
    const caretPosition = typeof inputElement.selectionStart === 'number'
      ? inputElement.selectionStart
      : rawValue.length;
    const { sanitizedValue, nextCaret } = sanitizeCitySearchValueWithCaret(rawValue, caretPosition);
    if(rawValue !== sanitizedValue) {
      inputElement.value = sanitizedValue;
      if(typeof inputElement.setSelectionRange === 'function') {
        inputElement.setSelectionRange(nextCaret, nextCaret);
      }
    }
    return inputElement.value;
  }

  function handleCitySearchBeforeInput(event) {
    if(!event || typeof event.data !== 'string') {
      return;
    }
    if(event.data && !CITY_ALLOWED_TEXT_REGEX.test(event.data)) {
      event.preventDefault();
    }
  }

  function renderCitySuggestions(filterText = '', forceOpen = false) {
    if(!cityOptionsCache.length) {
      hideCitySuggestionsList();
      return;
    }
    const normalized = filterText.trim().toLowerCase();
    const matches = cityOptionsCache.filter((entry) => {
      if(!normalized) {
        return true;
      }
      return entry.name.toLowerCase().startsWith(normalized) || entry.display.toLowerCase().startsWith(normalized);
    }).slice(0, CITY_SUGGESTION_LIMIT);
    const shouldOpen = forceOpen || isCitySearchInputFocused();
    updateCitySuggestionList(matches, normalized, shouldOpen);
  }

  function isCitySearchInputFocused() {
    const input = document.getElementById('citySearchInput');
    return Boolean(input && document.activeElement === input);
  }

  function updateCitySuggestionList(matches, normalizedFilter, shouldOpen) {
    const listElement = document.getElementById('citySuggestionsList');
    if(!listElement) {
      syncCitySearchExpandedState(false);
      return;
    }
    listElement.innerHTML = '';
    if(!shouldOpen) {
      listElement.hidden = true;
      syncCitySearchExpandedState(false);
      return;
    }
    if(!matches.length) {
      if(normalizedFilter) {
        const emptyState = document.createElement('div');
        emptyState.className = 'city-suggestion-empty';
        emptyState.textContent = 'لا توجد مدينة مطابقة';
        listElement.appendChild(emptyState);
        listElement.hidden = false;
        syncCitySearchExpandedState(true);
      } else {
        listElement.hidden = true;
        syncCitySearchExpandedState(false);
      }
      return;
    }
    const fragment = document.createDocumentFragment();
    matches.forEach((entry) => {
      const optionButton = document.createElement('button');
      optionButton.type = 'button';
      optionButton.className = 'city-suggestion-item';
      optionButton.dataset.cityName = entry.name;
      optionButton.dataset.display = entry.display;
      optionButton.textContent = entry.display;
      optionButton.setAttribute('role', 'option');
      fragment.appendChild(optionButton);
    });
    listElement.appendChild(fragment);
    listElement.hidden = false;
    syncCitySearchExpandedState(true);
  }

  function hideCitySuggestionsList() {
    cancelCitySuggestionsHide();
    const listElement = document.getElementById('citySuggestionsList');
    if(listElement) {
      listElement.hidden = true;
      listElement.innerHTML = '';
    }
    syncCitySearchExpandedState(false);
  }

  function syncCitySearchExpandedState(isOpen) {
    const input = document.getElementById('citySearchInput');
    if(input) {
      input.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }
  }

  function syncCityClearButtonVisibility() {
    const input = document.getElementById('citySearchInput');
    const clearBtn = document.getElementById('citySearchClearBtn');
    if(!clearBtn) {
      return;
    }
    const isDisabled = Boolean(input && input.hasAttribute('disabled'));
    const hasValue = Boolean(input && input.value && input.value.trim().length);
    clearBtn.hidden = isDisabled || !hasValue;
  }

  function handleCitySearchClear() {
    const input = document.getElementById('citySearchInput');
    if(input) {
      input.value = '';
      input.focus();
    }
    clearSelectedCityState();
    hideCitySuggestionsList();
    syncCityClearButtonVisibility();
  }

  function findCityMatchByInput(inputValue) {
    const normalized = inputValue ? inputValue.trim().toLowerCase() : '';
    if(!normalized) {
      return null;
    }
    return cityOptionsCache.find((entry) => entry.display.toLowerCase() === normalized || entry.name.toLowerCase() === normalized)
      || cityOptionsCache.find((entry) => entry.display.toLowerCase().startsWith(normalized) || entry.name.toLowerCase().startsWith(normalized))
      || null;
  }

  function applyCitySelectionFromName(name) {
    commitCitySelection(getCityEntryByName(name));
  }

  function handleCitySearchInput(event) {
    if(!event || !event.target) {
      return;
    }
    const value = enforceCitySearchAlphaOnly(event.target);
    cancelCitySuggestionsHide();
    renderCitySuggestions(value, true);
    const match = findCityMatchByInput(value);
    const normalized = value.trim().toLowerCase();
    if(match && (match.display.toLowerCase() === normalized || match.name.toLowerCase() === normalized)) {
      applyCitySelectionFromName(match.name);
    } else {
      clearSelectedCityState();
    }
    syncCityClearButtonVisibility();
  }

  function handleCitySearchFocus() {
    cancelCitySuggestionsHide();
    const input = document.getElementById('citySearchInput');
    const value = input ? input.value : '';
    renderCitySuggestions(value, true);
    syncCityClearButtonVisibility();
  }

  function handleCitySearchKeyDown(event) {
    if(event.key === 'Escape') {
      hideCitySuggestionsList();
      return;
    }
    if(event.key === 'Enter') {
      const match = findCityMatchByInput(event.target.value || '');
      if(match) {
        event.preventDefault();
        applyCitySelectionFromName(match.name);
      }
    }
  }

  function cancelCitySuggestionsHide() {
    if(citySuggestionsHideTimeoutId) {
      clearTimeout(citySuggestionsHideTimeoutId);
      citySuggestionsHideTimeoutId = null;
    }
  }

  function handleCitySearchBlur() {
    cancelCitySuggestionsHide();
    citySuggestionsHideTimeoutId = window.setTimeout(() => {
      const listElement = document.getElementById('citySuggestionsList');
      const searchInput = document.getElementById('citySearchInput');
      const activeElement = document.activeElement;
      if(activeElement && (activeElement === searchInput || (listElement && listElement.contains(activeElement)))) {
        return;
      }
      hideCitySuggestionsList();
    }, 120);
  }

  function handleCitySuggestionClick(event) {
    const target = event.target.closest('.city-suggestion-item');
    if(!target) {
      return;
    }
    const cityName = target.dataset.cityName;
    if(!cityName) {
      return;
    }
    applyCitySelectionFromName(cityName);
  }

  function handleOutsideCitySuggestionClick(event) {
    if(event.target.closest('.city-search-wrapper')) {
      return;
    }
    hideCitySuggestionsList();
  }

  function initCityPicker() {
    if(typeof fetch !== 'function') {
      return;
    }
    fetch('ville.json', { cache: 'no-store' })
      .then((response) => {
        if(!response.ok) {
          throw new Error('Failed to load cities');
        }
        return response.json();
      })
      .then(populateCityOptions)
      .catch(handleCityLoadError);
  }

  function populateCityOptions(cityData) {
    const flattened = flattenCityZones(cityData);
    const entries = Object.entries(flattened);
    if(!entries.length) {
      cityOptionsCache = [];
      clearSelectedCityState();
      updateCitySearchInputUI({ disabled: true, placeholderText: 'لا توجد مدن متاحة' });
      hideCitySuggestionsList();
      return;
    }
    cityOptionsCache = entries.map(([name, zoneKey]) => {
      const zoneLabel = getZoneDisplayLabel(zoneKey);
      return {
        name,
        zoneKey,
        display: zoneLabel ? `${name} — ${zoneLabel}` : name
      };
    }).sort((a, b) => a.name.localeCompare(b.name, 'ar', { sensitivity: 'base', numeric: true }));

    if(selectedCityName && !getCityEntryByName(selectedCityName)) {
      clearSelectedCityState();
    }

    updateCitySearchInputUI({ disabled: false });
    renderCitySuggestions('', false);
  }

  function handleCityLoadError() {
    cityOptionsCache = [];
    clearSelectedCityState();
    updateCitySearchInputUI({ disabled: true, placeholderText: 'تعذر تحميل المدن' });
    hideCitySuggestionsList();
  }

  function updateCityZoneBadge(zoneText) {
    const badge = document.getElementById('cityZoneBadge');
    if(!badge) return;
    if(!zoneText) {
      badge.textContent = '';
      badge.hidden = true;
      return;
    }
    badge.textContent = zoneText;
    badge.hidden = false;
  }


  function handleReload() {
    window.location.reload();
  }

  function setSingleResultCopyAvailability() {
    const resultDiv = document.getElementById('singleResult');
    const copyBtn = document.getElementById('copySingleResultBtn');
    if(!copyBtn || !resultDiv) {
      return;
    }
    copyBtn.disabled = resultDiv.innerText.trim().length === 0;
  }

  function fallbackCopyToClipboard(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'absolute';
    textarea.style.left = '-9999px';
    document.body.appendChild(textarea);
    textarea.select();
    let copied = false;
    try {
      copied = document.execCommand('copy');
    } catch (error) {
      copied = false;
    }
    document.body.removeChild(textarea);
    if(!copied) {
      alert('تعذر نسخ النتيجة تلقائيًا. الرجاء النسخ يدويًا.');
    }
  }

  function copySingleResult() {
    const resultDiv = document.getElementById('singleResult');
    if(!resultDiv) {
      return;
    }
    const text = resultDiv.innerText.trim();
    if(!text) {
      return;
    }
    if(navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
      navigator.clipboard.writeText(text).catch(() => fallbackCopyToClipboard(text));
    } else {
      fallbackCopyToClipboard(text);
    }
  }

  function convertCSV() {
    const file = document.getElementById('csvFile').files[0];
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('result');
    const downloadBtn = document.getElementById('downloadBtn');

    lastConvertedRows = [];
    lastConvertedFields = null;
    lastConversionType = null;
    if(downloadBtn) downloadBtn.disabled = true;

    if(type !== 'Merchich-to-latlong') {
      resultDiv.innerText = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S'').";
      return;
    }

    if(!file) {
      resultDiv.innerHTML = "Veuillez d'abord sélectionner un fichier CSV.";
      return;
    }

    if(file.size > MAX_FILE_SIZE_BYTES) {
      resultDiv.innerText = 'حجم الملف يتجاوز 1 ميغابايت المسموح بها. الرجاء اختيار ملف أصغر ثم إعادة المحاولة.';
      return;
    }

    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: 'greedy',
      complete: function(results) {
        const data = results.data || [];
        if(data.length > MAX_CSV_ROWS) {
          resultDiv.innerText = `عدد الأسطر ${data.length} ويتجاوز الحد المسموح به (${MAX_CSV_ROWS})، الرجاء تقليص الملف ثم إعادة المحاولة.`;
          return;
        }
        const fields = (results.meta && Array.isArray(results.meta.fields)) ? results.meta.fields : [];
        if(!hasField(fields, 'X') || !hasField(fields, 'Y')) {
          const existing = fields.length ? fields.join(', ') : 'بدون رؤوس واضحة';
          resultDiv.innerText = `لم يتم العثور على عمودين باسم X و Y. الأعمدة الحالية في الملف: ${existing}`;
          return;
        }

        const warnings = new Set();
        const convertedRows = [];
        let textOutput = 'الإحداثيات المحوّلة (عمود A = Latitude، عمود B = Longitude):\n\n';
        let domainError = null;

        data.forEach((row, index) => {
          if(domainError) {
            return;
          }
          const xVal = getCsvField(row, 'X');
          const yVal = getCsvField(row, 'Y');
          if(xVal === undefined || yVal === undefined) return;
          const x = parseFloat(xVal);
          const y = parseFloat(yVal);
          if(isNaN(x) || isNaN(y)) return;

          const conversion = convertPlanarToWgs84Auto(x, y);
          if(conversion.status !== 'ok') {
            domainError = {
              type: conversion.errorType || 'zones',
              message: getDomainErrorMessage(conversion.errorType || 'zones')
            };
            return;
          }

          const { lon, lat, inferredZoneKey } = conversion;
          const zoneResolution = resolveZoneAlignment(inferredZoneKey, { requireConfirmation: Boolean(selectedCityName) });
          if(!zoneResolution.proceed) {
            domainError = {
              type: 'user-abort',
              message: zoneResolution.warning || 'تم إيقاف التحويل بناءً على اختيار المستخدم.'
            };
            return;
          }
          if(zoneResolution.warning) {
            warnings.add(zoneResolution.warning);
          }

          const latDms = decimalToDMS(lat, true);
          const lonDms = decimalToDMS(lon, false);
          const latText = formatDMS(latDms);
          const lonText = formatDMS(lonDms);
          convertedRows.push({ Latitude: latText, Longitude: lonText });
          textOutput += `Ligne ${index + 1} : Latitude ${latText}, Longitude ${lonText}\n`;
        });

        if(domainError) {
          resultDiv.innerText = domainError.message;
          lastConvertedRows = [];
          lastConvertedFields = null;
          lastConversionType = null;
          if(downloadBtn) downloadBtn.disabled = true;
          return;
        }

        if(!convertedRows.length) {
          const attempted = data.length;
          resultDiv.innerText = `لم يتم العثور على صفوف صالحة للتحويل بعد فحص ${attempted} صفًا. تأكد من أن كل صف يحتوي على قيم رقمية في عمودي X و Y.`;
          return;
        }

        const warningText = warnings.size
          ? Array.from(warnings).map((text) => `تحذير: ${text}`).join('\n') + '\n\n'
          : '';
        resultDiv.innerText = `${warningText}${textOutput}`;

        lastConvertedRows = convertedRows;
        lastConvertedFields = ['Latitude', 'Longitude'];
        lastConversionType = type;
        if(downloadBtn) downloadBtn.disabled = false;
      }
    });
  }


  function convertSingle() {
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('singleResult');
    const warnings = [];

    if(type === 'latlong-to-Merchich') {
      const geoValidation = validateGeographicInputs();
      if(geoValidation.status === 'incomplete') {
        resultDiv.innerText = 'الرجاء إدخال قيم كاملة للخطوط قبل التحويل.';
        setSingleResultCopyAvailability();
        return;
      }
      if(geoValidation.status === 'invalid-input') {
        resultDiv.innerText = "Veuillez saisir des degrés، minutes et secondes valides pour la latitude et la longitude.";
        setSingleResultCopyAvailability();
        return;
      }
      if(geoValidation.status !== 'validated') {
        resultDiv.innerText = 'لا يمكن التحقق من المدخلات الحالية. تحقق من القيم المدخلة ثم أعد المحاولة.';
        setSingleResultCopyAvailability();
        return;
      }

      const latitude = geoValidation.latValue;
      const longitude = geoValidation.lonValue;

      if(!isPointInsideMorocco(longitude, latitude)) {
        setInputsValidity(GEO_COORD_INPUT_IDS, { isValid: false, message: MOROCCO_DOMAIN_ERROR_TEXT });
        resultDiv.innerText = MOROCCO_DOMAIN_ERROR_TEXT;
        setSingleResultCopyAvailability();
        return;
      }

      const inferredZoneKey = getZoneKeyForLatitude(latitude);
      if(!inferredZoneKey) {
        setInputsValidity(GEO_COORD_INPUT_IDS, { isValid: false, message: ZONE_RANGE_ERROR_TEXT });
        resultDiv.innerText = ZONE_RANGE_ERROR_TEXT;
        setSingleResultCopyAvailability();
        return;
      }

      const zoneResolution = resolveZoneAlignment(inferredZoneKey, { requireConfirmation: Boolean(selectedCityName) });
      if(!zoneResolution.proceed) {
        resultDiv.innerText = zoneResolution.warning || 'تم إلغاء العملية بناءً على اختيار المستخدم.';
        setSingleResultCopyAvailability();
        return;
      }
      if(zoneResolution.warning) {
        warnings.push(zoneResolution.warning);
      }

      const zoneConfig = merchichZones[zoneResolution.zoneKey];
      if(!zoneConfig) {
        resultDiv.innerText = 'لا يوجد نظام إسقاط صالح متاح لهذه النقطة.';
        setSingleResultCopyAvailability();
        return;
      }

      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });

      const [xMerchich, yMerchich] = proj4(wgs84, zoneConfig.proj, [longitude, latitude]);
      const xInt = Math.round(xMerchich);
      const yInt = Math.round(yMerchich);
      const latDmsText = formatDMS(decimalToDMS(latitude, true));
      const lonDmsText = formatDMS(decimalToDMS(longitude, false));
      let output = `X = ${xInt}\nY = ${yInt}\nZone: ${getZoneDisplayLabel(zoneResolution.zoneKey) || zoneResolution.zoneKey}`;
      if(warnings.length) {
        output = `${warnings.join('\n')}\n\n${output}`;
      }
      resultDiv.innerText = output;
      setSingleResultCopyAvailability();
      updateConversionMarker(latitude, longitude, `الموقع الأصلي<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
      return;
    }

    const xInput = parseFloat(document.getElementById('manualX').value);
    const yInput = parseFloat(document.getElementById('manualY').value);

    if(isNaN(xInput) || isNaN(yInput)) {
      resultDiv.innerText = "Veuillez saisir des valeurs numériques valides pour X و Y.";
      setSingleResultCopyAvailability();
      return;
    }

    const planarConversion = convertPlanarToWgs84Auto(xInput, yInput);
    if(planarConversion.status !== 'ok') {
      const message = getDomainErrorMessage(planarConversion.errorType || 'zones');
      setInputsValidity(CARTESIAN_INPUT_IDS, { isValid: false, message });
      resultDiv.innerText = message;
      setSingleResultCopyAvailability();
      return;
    }

    const { lon, lat, inferredZoneKey } = planarConversion;
    const zoneResolution = resolveZoneAlignment(inferredZoneKey, { requireConfirmation: Boolean(selectedCityName) });
    if(!zoneResolution.proceed) {
      resultDiv.innerText = zoneResolution.warning || 'تم إلغاء العملية بناءً على اختيار المستخدم.';
      setSingleResultCopyAvailability();
      return;
    }
    if(zoneResolution.warning) {
      warnings.push(zoneResolution.warning);
    }

    setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
    const latDms = decimalToDMS(lat, true);
    const lonDms = decimalToDMS(lon, false);
    const latDmsText = formatDMS(latDms);
    const lonDmsText = formatDMS(lonDms);
    let output = `Latitude : ${latDmsText}\nLongitude : ${lonDmsText}`;
    if(warnings.length) {
      output = `${warnings.join('\n')}\n\n${output}`;
    }
    resultDiv.innerText = output;
    setSingleResultCopyAvailability();
    updateConversionMarker(lat, lon, `النقطة المحوّلة إلى Lat/Long<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
  }

  function downloadConvertedFile() {
    if(!lastConvertedRows.length) {
      alert('لا توجد نتائج متاحة للتحميل. الرجاء تنفيذ تحويل CSV أولاً.');
      return;
    }

    const unparseInput = lastConvertedFields ? { fields: lastConvertedFields, data: lastConvertedRows } : lastConvertedRows;
    const csvContent = Papa.unparse(unparseInput);
    const bom = '\ufeff';
    const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const prefix = lastConversionType === 'latlong-to-Merchich' ? 'Merchich' : 'latlong';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${prefix}-converted-${timestamp}.csv`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  const citySearchInputElement = document.getElementById('citySearchInput');
  if(citySearchInputElement) {
    citySearchInputElement.addEventListener('beforeinput', handleCitySearchBeforeInput);
    citySearchInputElement.addEventListener('input', handleCitySearchInput);
    citySearchInputElement.addEventListener('focus', handleCitySearchFocus);
    citySearchInputElement.addEventListener('keydown', handleCitySearchKeyDown);
    citySearchInputElement.addEventListener('blur', handleCitySearchBlur);
  }
  const citySearchClearButton = document.getElementById('citySearchClearBtn');
  if(citySearchClearButton) {
    citySearchClearButton.addEventListener('click', handleCitySearchClear);
  }
  const citySuggestionsListElement = document.getElementById('citySuggestionsList');
  if(citySuggestionsListElement) {
    citySuggestionsListElement.addEventListener('click', handleCitySuggestionClick);
  }
  document.addEventListener('click', handleOutsideCitySuggestionClick);
  document.addEventListener('keydown', (event) => {
    if(event.key === 'Escape') {
      if(measurementSelectionState) {
        cancelMeasurementSelection(true);
        return;
      }
      if(manualPointSelectionArmed) {
        setManualPointSelectionState(false);
      }
    }
  });
  const conversionTypeElement = document.getElementById('conversionType');
  if(conversionTypeElement) {
    conversionTypeElement.addEventListener('change', () => {
      updateFileHint();
      validateAllCoordinateGroups();
    });
  }
  const csvInputElement = document.getElementById('csvFile');
  if(csvInputElement) {
    csvInputElement.addEventListener('change', handleCsvFileChange);
  }
  window.addEventListener('beforeunload', stopGeoWatch);
  initDmsValidationListeners();
  initManualNumericFields();
  initMap();
  loadSavedPointsFromStorage();
  initCityPicker();
  updateFileHint();
  updateConvertButtonState();
  validateAllCoordinateGroups();
  setSingleResultCopyAvailability();
  syncCityClearButtonVisibility();
  setManualPointSelectionState(false);
  updateMapFullscreenUI();
  initMapActionsDropdownGuard();
  initSavedEntryDropdownPortals();
  renderSavedPointsList();
</script>

</body>
</html>
