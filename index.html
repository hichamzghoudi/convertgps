<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>محول إحداثيات X/Y و Lat/Long</title>
<link rel="icon" href="convertgps.png" type="image/x-jpg">
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>

</style>
</head>
<body dir="rtl">

<div class="container">
  <h3 class="my-3">محول إحداثيات X/Y و Lat/Long (D°M'S'')</h3>

  <div class="conversion-header">    
      <div class="city-select-block">
        <select id="citySelect" class="city-select" aria-label="اختر المدينة (اجباري)">
          <option value="">جارٍ تحميل المدن...</option>
        </select>
      </div>
      <span class="city-zone-badge" id="cityZoneBadge" hidden aria-live="polite"></span>
      <label class="my-2 conversion-label" for="conversionType">اختر نوع التحويل:</label>
      <div>
        <select id="conversionType" class="form-select form-select-lg mb-3" aria-label="اختر نوع التحويل">
          <option value="Merchich-to-latlong">Fm: X/Y --To→ Lat/Long (D°M'S'')</option>
          <option value="latlong-to-Merchich">Fm: Lat/Long (D°M'S'') --To→ X/Y</option>
        </select>
      </div>
  </div>
  <div class="live-layout">
    <div class="manual-box">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <h3 class="manual-title">تحويل قيمة واحدة</h3>
        <button type="button" class="reload-btn" onclick="handleReload()" aria-label="إعادة تحميل الصفحة">
          <span aria-hidden="true">⟳</span>
        </button>        
      </div>
      
      <p class="hint" id="manualHint"></p>
      <div class="manual-fields" id="dmsFields">
        <div class="dms-group">
          <label>خط العرض (شمال S/N جنوب):</label>
          <div class="dms-row">
            <input type="text" id="latDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="latHemisphere" class="hemisphere-select">
              <option value="N"> (N)</option>
              <option value="S"> (S)</option>
            </select>
          </div>
        </div>
        <div class="dms-group">
          <label>خط الطول (شرق W/E غرب):</label>
          <div class="dms-row">
            <input type="text" id="lonDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="lonHemisphere" class="hemisphere-select">
              <option value="E"> (E)</option>
              <option value="W" selected> (W)</option>
            </select>
          </div>
        </div>
      </div>
      <div class="manual-fields" id="cartesianFields">
        <input type="number" id="manualX" placeholder="X">
        <input type="number" id="manualY" placeholder="Y">
      </div>
      <button class="manual-btn" onclick="convertSingle()">تحويل الإحداثيات المدخلة</button>
      <div class="result single-result" id="singleResult"></div>
    </div>

    <div class="map-box">
      <h3>عرض النقطة على الخريطة</h3>
      <p class="hint">سيتم تحريك العلامة تلقائيًا إلى آخر نقطة تم تحويلها.</p>
      <div class="map-wrapper">
        <button type="button" class="gps-btn" onclick="locateUser()" aria-label="إظهار موقعي الحالي"><i class="bi bi-geo-alt-fill"></i> </button>
        <button type="button" class="basemap-btn" id="basemapToggle" onclick="toggleBasemap()" aria-pressed="false">التبديل بين الخرائط</button>
        <div id="map"></div>
      </div>
    </div>
  </div>

  <div id="batchSection">
    <h3>تحويل عدة قيم </h3>
    <label>اختر ملف CSV للإحداثيات (أعمدة X و Y):</label>
    <input type="file" id="csvFile" accept=".csv">
    <p class="hint" id="fileHint"></p>
    <img src="modelcsvxy.JPG" alt="نموذج ملف CSV" id="csvModelImage" class="csv-image">

    <button id="convertBtn" class="btntout" onclick="convertCSV()" disabled>تحويل جميع الإحداثيات</button>

    <p class="hint" id="layoutHint">بعد التحويل، ضع قيمة Latitude في العمود A وقيمة Longitude في العمود B داخل ملف Excel قبل أي معالجة إضافية.</p>

    <div class="result" id="result"></div>
    <button id="downloadBtn" class="download-btn" onclick="downloadConvertedFile()" disabled>تحميل الملف المحوّل</button>
  </div>
</div>

<script>
  const wgs84 = proj4.WGS84;
  const merchichZones = {
    Zone_I: {
      label: '',
      proj: '+proj=lcc +lat_1=33.3 +lat_0=33.3 +lon_0=-5.4 +k_0=0.999625769 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_II: {
      label: '',
      proj: '+proj=lcc +lat_1=29.7 +lat_0=29.7 +lon_0=-5.4 +k_0=0.999625769 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_III: {
      label: '',
      proj: '+proj=lcc +lat_1=26.1 +lat_0=26.1 +lon_0=-5.4 +k_0=0.999625769 +x_0=1200000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_IV: {
      label: '',
      proj: '+proj=lcc +lat_1=22.5 +lat_0=22.5 +lon_0=-5.4 +k_0=0.999625769 +x_0=1500000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    }
  };
  const defaultZoneKey = 'Zone_I';
  let currentZoneKey = defaultZoneKey;
  let lastConvertedRows = [];
  let lastConvertedFields = null;
  let lastConversionType = null;
  const defaultMapCenter = [33.9, -5.3];
  const basemapConfigs = [
    {
      key: 'osmfr',
      label: 'plan de la ville',
      url: 'https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
      options: {
        attribution: '&copy; OpenStreetMap France & contributors',
        maxZoom: 19
      }
    },
    {
      key: 'imagery',
      label: 'satellite',
      url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      options: {
        attribution: 'Tiles &copy; Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        maxZoom: 19
      }
    }
  ];
  const MAX_FILE_SIZE_BYTES = 1024 * 1024;
  const MAX_CSV_ROWS = 200;
  let mapInstance = null;
  let mapTileLayer = null;
  let currentBasemapIndex = 0;
  let conversionMarker = null;
  let userMarker = null;
  let userAccuracyCircle = null;
  let geoWatchId = null;
  let geoWatchTimeoutId = null;
  let coarseLocationWarned = false;

  function initMap() {
    const mapElement = document.getElementById('map');
    if(!mapElement || typeof L === 'undefined') {
      return;
    }
    mapInstance = L.map(mapElement, {
      zoomControl: false,
      scrollWheelZoom: false
    }).setView(defaultMapCenter, 6);

    L.control.zoom({ position: 'bottomright' }).addTo(mapInstance);

    L.control.scale({ position: 'bottomleft', metric: true, imperial: false }).addTo(mapInstance);

    applyBasemapLayer(currentBasemapIndex);

  }

  function applyBasemapLayer(index) {
    if(!mapInstance || !basemapConfigs.length) {
      return;
    }
    const normalizedIndex = ((index % basemapConfigs.length) + basemapConfigs.length) % basemapConfigs.length;
    const config = basemapConfigs[normalizedIndex];
    if(!config) {
      return;
    }
    if(mapTileLayer) {
      mapInstance.removeLayer(mapTileLayer);
    }
    mapTileLayer = L.tileLayer(config.url, config.options).addTo(mapInstance);
    currentBasemapIndex = normalizedIndex;
    updateBasemapToggleLabel();
  }

  function toggleBasemap() {
    if(!mapInstance) {
      return;
    }
    const nextIndex = (currentBasemapIndex + 1) % basemapConfigs.length;
    applyBasemapLayer(nextIndex);
  }

  function updateBasemapToggleLabel() {
    const toggleBtn = document.getElementById('basemapToggle');
    if(!toggleBtn) {
      return;
    }
    const current = basemapConfigs[currentBasemapIndex];
    const next = basemapConfigs[(currentBasemapIndex + 1) % basemapConfigs.length];
    toggleBtn.textContent = ` ( الانتقال إلى ${next.label})`;
    toggleBtn.setAttribute('aria-label', `التبديل من ${current.label} إلى ${next.label}`);
    toggleBtn.setAttribute('aria-pressed', current.key === 'imagery' ? 'true' : 'false');
  }

  function updateConversionMarker(latitude, longitude, labelText, zoomLevel = 14) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!conversionMarker) {
      conversionMarker = L.circleMarker(target, {
        radius: 10,
        color: '#d61f46',
        fillColor: '#d61f46',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      conversionMarker.setLatLng(target);
    }
    if(labelText) {
      conversionMarker.bindPopup(labelText).openPopup();
    }
    mapInstance.setView(target, zoomLevel);
  }

  function updateUserLocationMarker(latitude, longitude, labelText, zoomLevel = 16) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!userMarker) {
      userMarker = L.circleMarker(target, {
        radius: 10,
        color: '#1fa86d',
        fillColor: '#1fa86d',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      userMarker.setLatLng(target);
    }
    if(labelText) {
      userMarker.bindPopup(labelText).openPopup();
    }
    mapInstance.setView(target, zoomLevel);
  }

  function locateUser() {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    if(!navigator.geolocation) {
      alert('GPS غير مدعوم في هذا المتصفح');
      return;
    }

    stopGeoWatch();
    coarseLocationWarned = false;
    const geoOptions = {
      enableHighAccuracy: true,
      timeout: 15000,
      maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy === null || accuracy > 120) {
          startGeoWatch(geoOptions);
        }
      },
      (error) => {
        handleUserLocationError(error);
      },
      geoOptions
    );
  }

  function handleUserLocationSuccess(position) {
    const latitude = position.coords.latitude;
    const longitude = position.coords.longitude;
    const accuracy = Number.isFinite(position.coords.accuracy) ? Math.round(position.coords.accuracy) : null;
    const latDmsText = formatDMS(decimalToDMS(latitude, true));
    const lonDmsText = formatDMS(decimalToDMS(longitude, false));
    const popupHeader = accuracy !== null
      ? `Ma position actuelle (±${accuracy} m)`
      : 'Ma position actuelle';
    const popupText = `${popupHeader}<br>${wrapDmsHtml(latDmsText, lonDmsText)}`;

    updateUserLocationMarker(latitude, longitude, popupText, 16);

    const circleTarget = [latitude, longitude];
    if(accuracy !== null) {
      if(!userAccuracyCircle) {
        userAccuracyCircle = L.circle(circleTarget, {
          radius: accuracy,
          color: '#1fa86d',
          fillColor: '#1fa86d',
          fillOpacity: 0.15,
          weight: 1
        }).addTo(mapInstance);
      } else {
        userAccuracyCircle.setLatLng(circleTarget);
        userAccuracyCircle.setRadius(accuracy);
      }
    } else if(userAccuracyCircle) {
      mapInstance.removeLayer(userAccuracyCircle);
      userAccuracyCircle = null;
    }

    if(accuracy !== null && accuracy > 10000 && !coarseLocationWarned) {
      alert('تم الحصول على موقع تقريبي فقط. الرجاء تفعيل GPS أو الاتصال بشبكة Wi-Fi للحصول على دقة أعلى.');
      coarseLocationWarned = true;
    }

    return accuracy;
  }

  function handleUserLocationError(error) {
    stopGeoWatch();
    if(error && error.code === error.PERMISSION_DENIED) {
      alert('تم رفض إذن الموقع');
      return;
    }
    if(error && error.code === error.POSITION_UNAVAILABLE) {
      alert('تعذر تحديد موقعك. تأكد من تفعيل GPS أو خدمات الموقع ثم أعد المحاولة.');
      return;
    }
    if(error && error.code === error.TIMEOUT) {
      alert('انتهت مهلة الحصول على الموقع. حاول مرة أخرى بعد التأكد من تفعيل GPS.');
      return;
    }
    alert('تعذر الحصول على الموقع الحالي');
  }

  function startGeoWatch(options) {
    if(typeof navigator.geolocation.watchPosition !== 'function') {
      return;
    }
    stopGeoWatch();
    geoWatchId = navigator.geolocation.watchPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy !== null && accuracy <= 60) {
          stopGeoWatch();
        }
      },
      (error) => {
        stopGeoWatch();
        handleUserLocationError(error);
      },
      options
    );

    geoWatchTimeoutId = window.setTimeout(() => {
      stopGeoWatch();
    }, 20000);
  }

  function stopGeoWatch() {
    if(geoWatchId !== null) {
      navigator.geolocation.clearWatch(geoWatchId);
      geoWatchId = null;
    }
    if(geoWatchTimeoutId) {
      clearTimeout(geoWatchTimeoutId);
      geoWatchTimeoutId = null;
    }
  }

  function updateFileHint() {
    const type = document.getElementById('conversionType').value;
    const hint = document.getElementById('fileHint');
    const manualHint = document.getElementById('manualHint');
    const csvImage = document.getElementById('csvModelImage');
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const batchSection = document.getElementById('batchSection');
    toggleManualFields(type);

    if(type === "latlong-to-Merchich") {
      const disabledMsg = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S''). الرجاء استخدام التحويل اليدوي لهذا الاتجاه.";
      if(hint) {
        hint.dataset.defaultMessage = disabledMsg;
        hint.innerText = disabledMsg;
      }
      manualHint.innerText = "أدخل خطوط الطول والعرض (D°M'S'') ليتم تحويلها إلى إحداثيات X و Y باستخدام المنطقة المرتبطة بالمدينة المختارة.";
      if(batchSection) batchSection.style.display = 'none';
      if(csvImage) {
        csvImage.style.display = 'none';
      }
      if(fileInput) {
        fileInput.value = '';
        fileInput.disabled = true;
      }
      if(convertBtn) convertBtn.disabled = true;
      if(downloadBtn) downloadBtn.disabled = true;
      lastConvertedRows = [];
      lastConvertedFields = null;
    } else {
      const activeMsg = "ارفع ملف CSV (أعمدة X و Y) بحجم لا يتجاوز 1 ميغابايت وبعدد أسطر لا يتخطى 200 ليتم تحويله إلى Lat/Long (D°M'S'') وفق المنطقة الخاصة بالمدينة المختارة أو المنطقة الافتراضية.";
      if(hint) {
        hint.dataset.defaultMessage = activeMsg;
        hint.innerText = activeMsg;
      }
      manualHint.innerText = "أدخل إحداثيات (X, Y) يدويًا ليتم تحويلها مباشرة إلى Lat/Long باستخدام المنطقة المناسبة.";
      if(batchSection) batchSection.style.display = 'block';
      if(csvImage) {
        csvImage.src = 'modelcsvxy.JPG';
        csvImage.style.display = 'block';
      }
      if(fileInput) fileInput.disabled = false;
      updateConvertButtonState();
    }
  }

  function toggleManualFields(type) {
    const dmsFields = document.getElementById('dmsFields');
    const cartesianFields = document.getElementById('cartesianFields');
    if(type === "latlong-to-Merchich") {
      dmsFields.style.display = 'flex';
      cartesianFields.style.display = 'none';
    } else {
      dmsFields.style.display = 'none';
      cartesianFields.style.display = 'flex';
    }
  }

  function dmsToDecimal(deg, min, sec, hemisphere) {
    if(isNaN(deg) || isNaN(min) || isNaN(sec)) {
      return NaN;
    }
    const absValue = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const hemisphereSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    const degreeSign = deg < 0 ? -1 : 1;
    return absValue * hemisphereSign * degreeSign;
  }

  function decimalToDMS(value, isLatitude) {
    if(isNaN(value)) return null;
    const absValue = Math.abs(value);
    const degrees = Math.floor(absValue);
    const minutesFloat = (absValue - degrees) * 60;
    const minutes = Math.floor(minutesFloat);
    const seconds = (minutesFloat - minutes) * 60;
    const hemisphere = isLatitude
      ? (value < 0 ? 'S' : 'N')
      : (value < 0 ? 'W' : 'E');
    return { degrees, minutes, seconds, hemisphere, isLatitude };
  }

  function padTwoDigits(value) {
    return value < 10 ? `0${value}` : `${value}`;
  }

  function padSeconds(seconds) {
    const str = seconds.toFixed(2);
    return seconds < 10 ? `0${str}` : str;
  }

  function enforceTwoDigits(input) {
    input.value = input.value.replace(/[^0-9]/g, '').slice(0, 2);
  }

  function sanitizeSeconds(input) {
    let value = input.value.replace(/[^0-9.,]/g, '');
    const decimalIndex = value.search(/[.,]/);
    if(decimalIndex !== -1) {
      const before = value.slice(0, decimalIndex + 1);
      const after = value.slice(decimalIndex + 1).replace(/[.,]/g, '');
      value = before + after;
    }
    input.value = value;
  }

  function finalizeSeconds(input) {
    let value = input.value.trim();
    if(value === '') return;
    const usesComma = value.includes(',');
    const usesDot = value.includes('.');
    const normalized = value.replace(',', '.');
    let num = parseFloat(normalized);
    if(isNaN(num)) {
      input.value = '';
      return;
    }
    num = Math.min(59.99, Math.max(0, num));
    if(usesComma || usesDot) {
      const truncated = Math.floor(num * 100) / 100;
      let str = truncated.toFixed(2);
      if(usesComma && !usesDot) {
        str = str.replace('.', ',');
      }
      input.value = str;
    } else {
      input.value = Math.round(num).toString();
    }
  }

  function readSecondsValue(elementId) {
    const raw = document.getElementById(elementId).value.trim();
    if(raw === '') return NaN;
    const normalized = raw.replace(',', '.');
    const num = parseFloat(normalized);
    if(isNaN(num)) return NaN;
    const clamped = Math.min(59.99, Math.max(0, num));
    return Math.floor(clamped * 100) / 100;
  }

  function formatDMS(dms) {
    if(!dms) return '';
    const degreeWidth = dms.isLatitude ? 2 : 3;
    const degreeStr = dms.degrees.toString().padStart(degreeWidth, '0');
    const minuteStr = padTwoDigits(dms.minutes);
    const secondStr = padSeconds(dms.seconds);
    return `${degreeStr}° ${minuteStr}' ${secondStr}" ${dms.hemisphere}`;
  }

  function wrapDmsHtml(latText, lonText) {
    const safeLat = latText || '';
    const safeLon = lonText || '';
    return `<span class="dms-popup">${safeLat}<br>${safeLon}</span>`;
  }

  function normalizeDmsString(value) {
    return value.toString()
      .replace(/,/g, '.')
      .replace(/″|”|“/g, '"')
      .replace(/′|’|`/g, "'")
      .replace(/º|˚/g, '°')
      .trim();
  }

  function parseCsvDms(value, hemisphere) {
    if(value === undefined || value === null) return NaN;
    const normalized = normalizeDmsString(value);
    const cleaned = normalized
      .replace(/[NSEW]\s*$/i, '')
      .replace(/"/g, '')
      .trim();
    const regex = /(-?\d+(?:\.\d+)?)\s*°\s*(\d+(?:\.\d+)?)\s*['′’]\s*(\d+(?:\.\d+)?)/;
    const match = cleaned.match(regex);
    if(!match) return NaN;
    const deg = parseFloat(match[1]);
    const min = parseFloat(match[2]);
    const sec = parseFloat(match[3]);
    const base = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const degreeSign = deg < 0 ? -1 : 1;
    const hemiSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    return base * degreeSign * hemiSign;
  }

  function getCsvField(row, targetKey) {
    const normalizedTarget = normalizeKeyName(targetKey);
    for (const key in row) {
      if(!Object.prototype.hasOwnProperty.call(row, key)) continue;
      if(typeof key !== 'string') continue;
      if(normalizeKeyName(key) === normalizedTarget) {
        return row[key];
      }
    }
    return undefined;
  }

  function hasField(fields, targetKey) {
    if(!Array.isArray(fields)) return false;
    const normalizedKey = normalizeKeyName(targetKey);
    return fields.some(field => {
      if(field === undefined || field === null) return false;
      return normalizeKeyName(field) === normalizedKey;
    });
  }

  function normalizeKeyName(key) {
    if(key === undefined || key === null) return '';
    return key.toString().replace(/\ufeff/g, '').trim().toLowerCase();
  }

  function updateConvertButtonState() {
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const type = document.getElementById('conversionType').value;
    if(!convertBtn || !fileInput) return;
    if(type !== 'Merchich-to-latlong') {
      convertBtn.disabled = true;
      return;
    }
    const file = fileInput.files[0];
    const isValidSize = file ? file.size <= MAX_FILE_SIZE_BYTES : false;
    convertBtn.disabled = !isValidSize;
  }

  function handleCsvFileChange() {
    const fileInput = document.getElementById('csvFile');
    const hint = document.getElementById('fileHint');
    if(!fileInput) return;
    const file = fileInput.files[0];
    if(file && file.size > MAX_FILE_SIZE_BYTES) {
      const sizeMb = (file.size / (1024 * 1024)).toFixed(2);
      if(hint) {
        hint.innerText = `حجم الملف ${sizeMb} ميغابايت وهو أكبر من الحد المسموح (1 ميغابايت). اختر ملفًا أصغر ثم أعد المحاولة.`;
      }
      fileInput.value = '';
    } else if(hint && hint.dataset.defaultMessage) {
      hint.innerText = hint.dataset.defaultMessage;
    }

    updateConvertButtonState();
    lastConvertedRows = [];
    lastConvertedFields = null;
    const downloadBtn = document.getElementById('downloadBtn');
    if(downloadBtn) downloadBtn.disabled = true;
  }

  function normalizeZoneKey(zoneValue) {
    if(typeof zoneValue !== 'string') {
      return '';
    }
    return zoneValue
      .trim()
      .replace(/\s+/g, '_')
      .replace(/-+/g, '_')
      .replace(/zone/gi, 'Zone');
  }

  function getZoneDisplayLabel(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    const zoneConfig = merchichZones[normalized];
    if(zoneConfig && zoneConfig.label) {
      return zoneConfig.label;
    }
    return normalized ? normalized.replace(/_/g, ' ') : '';
  }

  function getCurrentZoneConfig() {
    return merchichZones[currentZoneKey] || merchichZones[defaultZoneKey] || null;
  }

  function setActiveZone(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    if(normalized && merchichZones[normalized]) {
      currentZoneKey = normalized;
    } else {
      currentZoneKey = defaultZoneKey;
    }
  }


  function flattenCityZones(cityData) {
    const flattened = {};
    if(!cityData || typeof cityData !== 'object') {
      return flattened;
    }
    Object.entries(cityData).forEach(([key, value]) => {
      if(Array.isArray(value)) {
        const zoneKey = normalizeZoneKey(key);
        if(!zoneKey) {
          return;
        }
        value.forEach((cityName) => {
          if(typeof cityName !== 'string') {
            return;
          }
          const trimmed = cityName.trim();
          if(!trimmed) {
            return;
          }
          flattened[trimmed] = zoneKey;
        });
        return;
      }
      if(typeof value === 'string') {
        const zoneKey = normalizeZoneKey(value);
        if(!zoneKey) {
          return;
        }
        const trimmedKey = typeof key === 'string' ? key.trim() : key;
        if(!trimmedKey) {
          return;
        }
        flattened[trimmedKey] = zoneKey;
      }
    });
    return flattened;
  }

  function initCityPicker() {
    const citySelect = document.getElementById('citySelect');
    if(!citySelect || typeof fetch !== 'function') {
      return;
    }
    fetch('ville.json', { cache: 'no-store' })
      .then((response) => {
        if(!response.ok) {
          throw new Error('Failed to load cities');
        }
        return response.json();
      })
      .then((data) => populateCitySelect(citySelect, data))
      .catch(() => handleCityLoadError(citySelect));
  }

  function populateCitySelect(citySelect, cityData) {
    if(!citySelect) return;
    citySelect.innerHTML = '';
    const placeholderOption = document.createElement('option');
    placeholderOption.value = '';
    placeholderOption.textContent = 'اختر المدينة (اجباري)';
    citySelect.appendChild(placeholderOption);
    const flattened = flattenCityZones(cityData);
    const entries = Object.entries(flattened);
    if(!entries.length) {
      citySelect.disabled = true;
      placeholderOption.textContent = 'لا توجد مدن متاحة';
      return;
    }
    entries.sort((a, b) => a[0].localeCompare(b[0], 'ar', { sensitivity: 'base', numeric: true }));
    entries.forEach(([name, zoneKey]) => {
      const option = document.createElement('option');
      const zoneLabel = getZoneDisplayLabel(zoneKey);
      option.value = name;
      option.textContent = zoneLabel ? `${name} — ${zoneLabel}` : name;
      if(zoneKey) {
        option.dataset.zoneKey = zoneKey;
      }
      citySelect.appendChild(option);
    });
  }

  function handleCityLoadError(citySelect) {
    if(!citySelect) return;
    citySelect.innerHTML = '<option value="">تعذر تحميل المدن</option>';
    citySelect.disabled = true;
  }

  function handleCitySelection() {
    const citySelect = document.getElementById('citySelect');
    if(!citySelect) return;
    const selectedOption = citySelect.options[citySelect.selectedIndex];
    const zoneKey = selectedOption && selectedOption.dataset.zoneKey ? selectedOption.dataset.zoneKey : '';
    const normalizedZone = normalizeZoneKey(zoneKey);
    const hasSupportedZone = Boolean(normalizedZone && merchichZones[normalizedZone]);
    setActiveZone(hasSupportedZone ? normalizedZone : '');
    updateCityZoneBadge(hasSupportedZone ? getZoneDisplayLabel(normalizedZone) : '');
  }

  function updateCityZoneBadge(zoneText) {
    const badge = document.getElementById('cityZoneBadge');
    if(!badge) return;
    if(!zoneText) {
      badge.textContent = '';
      badge.hidden = true;
      return;
    }
    badge.textContent = zoneText;
    badge.hidden = false;
  }

  function handleReload() {
    window.location.reload();
  }

  function convertCSV() {
    const file = document.getElementById('csvFile').files[0];
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('result');
    const downloadBtn = document.getElementById('downloadBtn');
    const zoneConfig = getCurrentZoneConfig();

    if(!zoneConfig) {
      resultDiv.innerText = 'لا يوجد نظام إسقاط صالح لهذا التحويل. الرجاء اختيار مدينة مرتبطة بمنطقة معتمدة.';
      return;
    }

    const zoneLabel = getZoneDisplayLabel(currentZoneKey) || 'Zone I';

    lastConvertedRows = [];
    lastConvertedFields = null;
    lastConversionType = null;
    if(downloadBtn) downloadBtn.disabled = true;

    if(type !== "Merchich-to-latlong") {
      resultDiv.innerText = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S'').";
      return;
    }

    if (!file) {
      resultDiv.innerHTML = "Veuillez d'abord sélectionner un fichier CSV.";
      return;
    }

    if(file.size > MAX_FILE_SIZE_BYTES) {
      resultDiv.innerText = 'حجم الملف يتجاوز 1 ميغابايت المسموح بها. الرجاء اختيار ملف أصغر ثم إعادة المحاولة.';
      return;
    }

    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: 'greedy',
      complete: function(results) {
        const data = results.data || [];
        if(data.length > MAX_CSV_ROWS) {
          resultDiv.innerText = `عدد الأسطر ${data.length} ويتجاوز الحد المسموح به (${MAX_CSV_ROWS})، الرجاء تقليص الملف ثم إعادة المحاولة.`;
          return;
        }
        const fields = (results.meta && Array.isArray(results.meta.fields)) ? results.meta.fields : [];
        if(!hasField(fields, 'X') || !hasField(fields, 'Y')) {
          const existing = fields.length ? fields.join(', ') : 'بدون رؤوس واضحة';
          resultDiv.innerText = `لم يتم العثور على عمودين باسم X و Y. الأعمدة الحالية في الملف: ${existing}`;
          return;
        }
        let output = `الإحداثيات المحوّلة (عمود A = Latitude، عمود B = Longitude) — ${zoneLabel}:\n\n`;
        const convertedRows = [];

        data.forEach((row, index) => {
          const xVal = getCsvField(row, 'X');
          const yVal = getCsvField(row, 'Y');
          if(xVal === undefined || yVal === undefined) return;
          const x = parseFloat(xVal);
          const y = parseFloat(yVal);
          if(isNaN(x) || isNaN(y)) return;

          const [lon, lat] = proj4(zoneConfig.proj, wgs84, [x, y]);
          const latDms = decimalToDMS(lat, true);
          const lonDms = decimalToDMS(lon, false);
          output += `Ligne ${index+1} : Latitude ${formatDMS(latDms)}, Longitude ${formatDMS(lonDms)}\n`;
          convertedRows.push({ Latitude: formatDMS(latDms), Longitude: formatDMS(lonDms) });
        });

        if(!convertedRows.length) {
          const attempted = data.length;
          resultDiv.innerText = `لم يتم العثور على صفوف صالحة للتحويل بعد فحص ${attempted} صفًا. تأكد من أن كل صف يحتوي على قيم رقمية في عمودي X و Y.`;
          return;
        }

        resultDiv.innerText = output;
        lastConvertedRows = convertedRows;
        lastConvertedFields = ['Latitude', 'Longitude'];
        lastConversionType = type;
        if(downloadBtn) downloadBtn.disabled = false;
      }
    });
  }

  function convertSingle() {
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('singleResult');
    const citySelect = document.getElementById('citySelect');
    if(citySelect && !citySelect.value) {
      resultDiv.innerText = 'الرجاء اختيار مدينة من القائمة قبل إجراء التحويل.';
      citySelect.focus();
      return;
    }
    const zoneConfig = getCurrentZoneConfig();

    if(!zoneConfig) {
      resultDiv.innerText = 'لا يوجد نظام إسقاط صالح متاح. الرجاء اختيار مدينة مرتبطة بمنطقة معتمدة.';
      return;
    }

    const zoneLabel = getZoneDisplayLabel(currentZoneKey) || 'Zone I';

    if(type === "latlong-to-Merchich") {
      const latDeg = parseFloat(document.getElementById('latDeg').value);
      const latMin = parseFloat(document.getElementById('latMin').value);
      const latSec = readSecondsValue('latSec');
      const lonDeg = parseFloat(document.getElementById('lonDeg').value);
      const lonMin = parseFloat(document.getElementById('lonMin').value);
      const lonSec = readSecondsValue('lonSec');
      const latHem = document.getElementById('latHemisphere').value;
      const lonHem = document.getElementById('lonHemisphere').value;

      const latitude = dmsToDecimal(latDeg, latMin, latSec, latHem);
      const longitude = dmsToDecimal(lonDeg, lonMin, lonSec, lonHem);

      if(isNaN(latitude) || isNaN(longitude)) {
        resultDiv.innerText = "Veuillez saisir des degrés, minutes et secondes valides pour la latitude et la longitude.";
        return;
      }

      const [xMerchich, yMerchich] = proj4(wgs84, zoneConfig.proj, [longitude, latitude]);
      const xInt = Math.round(xMerchich);
      const yInt = Math.round(yMerchich);
      resultDiv.innerText = `X = ${xInt}\nY = ${yInt}\nZone: ${zoneLabel}`;
      const latDmsText = formatDMS(decimalToDMS(latitude, true));
      const lonDmsText = formatDMS(decimalToDMS(longitude, false));
      updateConversionMarker(latitude, longitude, `الموقع الأصلي<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
    } else {
      const xInput = parseFloat(document.getElementById('manualX').value);
      const yInput = parseFloat(document.getElementById('manualY').value);

      if(isNaN(xInput) || isNaN(yInput)) {
        resultDiv.innerText = "Veuillez saisir des valeurs numériques valides pour X et Y.";
        return;
      }

      const [lon, lat] = proj4(zoneConfig.proj, wgs84, [xInput, yInput]);
      const latDms = decimalToDMS(lat, true);
      const lonDms = decimalToDMS(lon, false);
      const latDmsText = formatDMS(latDms);
      const lonDmsText = formatDMS(lonDms);
      resultDiv.innerText = `Latitude : ${latDmsText}\nLongitude : ${lonDmsText}\nZone: ${zoneLabel}`;
      updateConversionMarker(lat, lon, `النقطة المحوّلة إلى Lat/Long<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
    }
  }

  function downloadConvertedFile() {
    if(!lastConvertedRows.length) {
      alert('لا توجد نتائج متاحة للتحميل. الرجاء تنفيذ تحويل CSV أولاً.');
      return;
    }

    const unparseInput = lastConvertedFields ? { fields: lastConvertedFields, data: lastConvertedRows } : lastConvertedRows;
    const csvContent = Papa.unparse(unparseInput);
    const bom = '\ufeff';
    const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const prefix = lastConversionType === 'latlong-to-Merchich' ? 'Merchich' : 'latlong';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${prefix}-converted-${timestamp}.csv`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  document.getElementById('citySelect').addEventListener('change', handleCitySelection);
  document.getElementById('conversionType').addEventListener('change', updateFileHint);
  document.getElementById('csvFile').addEventListener('change', handleCsvFileChange);
  window.addEventListener('beforeunload', stopGeoWatch);
  initMap();
  initCityPicker();
  updateFileHint();
  updateConvertButtonState();
</script>

</body>
</html>
