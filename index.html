<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>محول إحداثيات X/Y و Lat/Long</title>
<link rel="icon" href="convertgps.png" type="image/x-jpg">
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>

</style>
</head>
<body dir="rtl">

<div class="container">
  <img src="convertgps.png" type="image/x-jpg" alt="" style="width: 2rem; margin: auto; display: flex;">
  <h4 class="my-3">محول إحداثيات X/Y و Lat/Long (D°M'S'')</h4>

  <div class="conversion-header">
    <div class="city-picker ">
      <label class="conversion-label" for="citySearchInput">اختر المدينة (اجباري)</label>
      <div class="city-select-block">
        <div class="city-search-wrapper">
          <input type="text" id="citySearchInput" class="form-control city-search-input" placeholder="أدخل اسم المدينة..." autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-controls="citySuggestionsList">
          <button type="button" id="citySearchClearBtn" class="city-clear-btn" aria-label="مسح اسم المدينة" hidden>&times;</button>
          <div id="citySuggestionsList" class="city-suggestions" role="listbox" hidden></div>
        </div>
        <span class="city-zone-badge" id="cityZoneBadge" hidden aria-live="polite"></span>
      </div>
      <!--<p class="hint">يتم استخدام المدينة فقط لتأكيد نطاق المنطقة، وسيتم اختيار المنطقة الصحيحة تلقائيًا.</p>-->
    </div>

    <div class="conversion-type">
      <label class="conversion-label" for="conversionType">اختر نوع التحويل:</label>
      <select id="conversionType" class="form-select form-select-lg mb-3" aria-label="اختر نوع التحويل">
        <option value="Merchich-to-latlong">X/Y <span style='font-size:100px;'>&#8667;</span> Lat/Long (D°M'S'')</option>
        <option value="latlong-to-Merchich">Lat/Long (D°M'S'') <span style='font-size:100px;'>&#8667;</span> X/Y</option>
      </select>
    </div>
  </div>

  <div class="live-layout">
    <div class="manual-box">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <h4 class="manual-title">تحويل قيمة واحدة</h4>
        <button type="button" class="reload-btn" onclick="handleReload()" aria-label="إعادة تحميل الصفحة">
          <span aria-hidden="true">⟳</span>
        </button>
      </div>

      <p class="hint" id="manualHint"></p>
      <div class="manual-fields" id="dmsFields">
        <div class="dms-group">
          <label>خط العرض (شمال S/N جنوب):</label>
          <div class="dms-row">
            <input type="text" id="latDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="latHemisphere" class="hemisphere-select">
              <option value="N">(N)</option>
              <option value="S">(S)</option>
            </select>
          </div>
        </div>
        <div class="dms-group">
          <label>خط الطول (شرق W/E غرب):</label>
          <div class="dms-row">
            <input type="text" id="lonDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="lonHemisphere" class="hemisphere-select">
              <option value="E">(E)</option>
              <option value="W" selected>(W)</option>
            </select>
          </div>
        </div>
      </div>

      <div class="manual-fields" id="cartesianFields">
        <input type="text" id="manualX" placeholder="X">
        <input type="text" id="manualY" placeholder="Y">
      </div>

      <button class="manual-btn rounded" onclick="convertSingle()">تحويل الإحداثيات المدخلة</button>
      <button type="button" id="copySingleResultBtn" class="btntout mt-2 rounded" onclick="copySingleResult()" disabled>نسخ النتيجة</button>
      <div class="result single-result" id="singleResult"></div>
    </div>

    <div class="map-box">
      <h3>عرض النقطة على الخريطة</h3>
      <p class="hint">سيتم تحريك العلامة تلقائيًا إلى آخر نقطة تم تحويلها، ويمكنك وضع علامة جديدة عبر الضغط على زر "تحديد نقطة على الخريطة" ثم اختيار الموضع على الخريطة.</p>
      <div class="map-wrapper">
        <button type="button" class="gps-btn" onclick="locateUser()" aria-label="إظهار موقعي الحالي"><i class="bi bi-geo-alt-fill"></i></button>
        <button type="button" class="select-point-btn" id="manualPointSelectBtn" onclick="toggleManualPointSelection()" aria-pressed="false">تحديد نقطة على الخريطة</button>
        <button type="button" class="basemap-btn" id="basemapToggle" onclick="toggleBasemap()" aria-pressed="false">التبديل بين الخرائط</button>
        <div id="map"></div>
      </div>
    </div>
  </div>

  <div id="batchSection">
    <h3>تحويل عدة قيم</h3>
    <label>اختر ملف CSV للإحداثيات (أعمدة X و Y):</label>
    <input type="file" id="csvFile" accept=".csv">
    <p class="hint" id="fileHint"></p>
    <img src="modelcsvxy.JPG" alt="نموذج ملف CSV" id="csvModelImage" class="csv-image">
    <button id="convertBtn" class="btntout rounded" onclick="convertCSV()" disabled>تحويل جميع الإحداثيات</button>
    <p class="hint" id="layoutHint">بعد التحويل، ضع قيمة Latitude في العمود A وقيمة Longitude في العمود B داخل ملف Excel قبل أي معالجة إضافية.</p>
    <div class="result" id="result"></div>
    <button id="downloadBtn" class="download-btn rounded" onclick="downloadConvertedFile()" disabled>تحميل الملف المحوّل</button>
  </div>
</div>

<script>
  const wgs84 = proj4.WGS84;
  const merchichZones = {
    Zone_I: {
      label: 'Zone I (Rabat - Casablanca)',
      proj: '+proj=lcc +lat_1=33.3 +lat_0=33.3 +lon_0=-5.4 +k_0=0.999615596 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_II: {
      label: 'Zone II (Agadir - Marrakech)',
      proj: '+proj=lcc +lat_1=29.7 +lat_0=29.7 +lon_0=-5.4 +k_0=0.999615596 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_III: {
      label: 'Zone III (La\'youn)',
      proj: '+proj=lcc +lat_1=26.1 +lat_0=26.1 +lon_0=-5.4 +k_0=0.999615596 +x_0=1200000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_IV: {
      label: 'Zone IV (Ad-Dakhla)',
      proj: '+proj=lcc +lat_1=22.5 +lat_0=22.5 +lon_0=-5.4 +k_0=0.999615596 +x_0=1500000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    }
  };

  const zoneValidationLimits = {
    Zone_I: {
      latRange: { min: 31.72786641202, max: 34.8717272112 }
    },
    Zone_II: {
      latRange: { min: 28.10632948, max: 31.2932791054 }
    },
    Zone_III: {
      latRange: { min: 24.5075340813, max: 27.6921073632 }
    },
    Zone_IV: {
      latRange: { min: 20.9075742561, max: 24.092105054 }
    }
  };

  const MOROCCO_BOUNDARY = {
    type: 'Feature',
    geometry: {
      type: 'Polygon',
      coordinates: [[
        [-5.193863, 35.755182],
        [-4.591006, 35.330712],
        [-3.640057, 35.399855],
        [-2.604306, 35.179093],
        [-2.169914, 35.168396],
        [-1.792986, 34.527919],
        [-1.733455, 33.919713],
        [-1.388049, 32.864015],
        [-1.124551, 32.651522],
        [-1.307899, 32.262889],
        [-2.616605, 32.094346],
        [-3.06898, 31.724498],
        [-3.647498, 31.637294],
        [-3.690441, 30.896952],
        [-4.859646, 30.501188],
        [-5.242129, 30.000443],
        [-6.060632, 29.7317],
        [-7.059228, 29.579228],
        [-8.674116, 28.841289],
        [-8.66559, 27.656426],
        [-8.817809, 27.656426],
        [-8.817828, 27.656426],
        [-8.794884, 27.120696],
        [-9.413037, 27.088476],
        [-9.735343, 26.860945],
        [-10.189424, 26.860945],
        [-10.551263, 26.990808],
        [-11.392555, 26.883424],
        [-11.71822, 26.104092],
        [-12.030759, 26.030866],
        [-12.500963, 24.770116],
        [-13.89111, 23.691009],
        [-14.221168, 22.310163],
        [-14.630833, 21.86094],
        [-14.750955, 21.5006],
        [-17.002962, 21.420734],
        [-17.020428, 21.42231],
        [-16.973248, 21.885745],
        [-16.589137, 22.158234],
        [-16.261922, 22.67934],
        [-16.326414, 23.017768],
        [-15.982611, 23.723358],
        [-15.426004, 24.359134],
        [-15.089332, 24.520261],
        [-14.824645, 25.103533],
        [-14.800926, 25.636265],
        [-14.43994, 26.254418],
        [-13.773805, 26.618892],
        [-13.139942, 27.640148],
        [-13.121613, 27.654148],
        [-12.618837, 28.038186],
        [-11.688919, 28.148644],
        [-10.900957, 28.832142],
        [-10.399592, 29.098586],
        [-9.564811, 29.933574],
        [-9.814718, 31.177736],
        [-9.434793, 32.038096],
        [-9.300693, 32.564679],
        [-8.657476, 33.240245],
        [-7.654178, 33.697065],
        [-6.912544, 34.110476],
        [-6.244342, 35.145865],
        [-5.929994, 35.759988],
        [-5.193863, 35.755182]
      ]]
    }
  };
  const defaultZoneKey = 'Zone_I';
  let currentZoneKey = defaultZoneKey;
  let lastConvertedRows = [];
  let lastConvertedFields = null;
  let lastConversionType = null;
  const defaultMapCenter = [33.9, -5.3];
  const basemapConfigs = [
    {
      key: 'osmfr',
      label: 'plan de la ville',
      url: 'https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
      options: {
        attribution: '&copy; OpenStreetMap France & contributors',
        maxZoom: 19
      }
    },
    {
      key: 'imagery',
      label: 'satellite',
      url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      options: {
        attribution: 'Tiles &copy; Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        maxZoom: 19
      }
    }
  ];
  const MAX_FILE_SIZE_BYTES = 1024 * 1024;
  const MAX_CSV_ROWS = 200;
  let mapInstance = null;
  let mapTileLayer = null;
  let currentBasemapIndex = 0;
  let conversionMarker = null;
  let userMarker = null;
  let manualPointSelectionArmed = false;
  let userAccuracyCircle = null;
  let geoWatchId = null;
  let geoWatchTimeoutId = null;
  let coarseLocationWarned = false;
  let cityOptionsCache = [];
  let selectedCityName = '';
  const CITY_SUGGESTION_LIMIT = 20;
  const CITY_ALLOWED_CHAR_REGEX = /^[A-Za-z ]$/;
  const CITY_ALLOWED_TEXT_REGEX = /^[A-Za-z ]+$/;
  const LAT_INPUT_IDS = ['latDeg', 'latMin', 'latSec'];
  const LON_INPUT_IDS = ['lonDeg', 'lonMin', 'lonSec'];
  const CARTESIAN_INPUT_IDS = ['manualX', 'manualY'];
  const GEO_COORD_INPUT_IDS = [...LAT_INPUT_IDS, ...LON_INPUT_IDS];
  const ZONE_RANGE_ERROR_TEXT = 'النقطة خارج نطاق Zones المغربية';
  const MOROCCO_DOMAIN_ERROR_TEXT = 'النقطة خارج المجال الجغرافي للمغرب';
  const ZONE_MISMATCH_WARNING_TEMPLATE = 'هذه النقطة تقع في {actualZone}، وليس {selectedZone}.';
  let citySuggestionsHideTimeoutId = null;

  function initMap() {
    const mapElement = document.getElementById('map');
    if(!mapElement || typeof L === 'undefined') {
      return;
    }
    mapInstance = L.map(mapElement, {
      zoomControl: false,
      scrollWheelZoom: false
    }).setView(defaultMapCenter, 6);

    L.control.zoom({ position: 'bottomright' }).addTo(mapInstance);

    L.control.scale({ position: 'bottomleft', metric: true, imperial: false }).addTo(mapInstance);

    applyBasemapLayer(currentBasemapIndex);
    mapInstance.on('click', handleMapClick);

  }

  function applyBasemapLayer(index) {
    if(!mapInstance || !basemapConfigs.length) {
      return;
    }
    const normalizedIndex = ((index % basemapConfigs.length) + basemapConfigs.length) % basemapConfigs.length;
    const config = basemapConfigs[normalizedIndex];
    if(!config) {
      return;
    }
    if(mapTileLayer) {
      mapInstance.removeLayer(mapTileLayer);
    }
    mapTileLayer = L.tileLayer(config.url, config.options).addTo(mapInstance);
    currentBasemapIndex = normalizedIndex;
    updateBasemapToggleLabel();
  }

  function toggleBasemap() {
    if(!mapInstance) {
      return;
    }
    const nextIndex = (currentBasemapIndex + 1) % basemapConfigs.length;
    applyBasemapLayer(nextIndex);
  }

  function toggleManualPointSelection() {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    setManualPointSelectionState(!manualPointSelectionArmed);
  }

  function setManualPointSelectionState(isActive) {
    manualPointSelectionArmed = Boolean(isActive);
    const mapElement = document.getElementById('map');
    if(mapElement) {
      mapElement.classList.toggle('map-select-armed', manualPointSelectionArmed);
    }
    updateManualPointSelectionUI();
  }

  function updateManualPointSelectionUI() {
    const button = document.getElementById('manualPointSelectBtn');
    if(!button) {
      return;
    }
    if(manualPointSelectionArmed) {
      button.classList.add('is-armed');
      button.textContent = 'اضغط على الخريطة الآن';
    } else {
      button.classList.remove('is-armed');
      button.textContent = 'تحديد نقطة  ';
    }
    button.setAttribute('aria-pressed', manualPointSelectionArmed ? 'true' : 'false');
  }

  function getConversionMarkerPopupHtml(bodyHtml) {
    const safeBody = bodyHtml || 'تم تثبيت النقطة.';
    return `
      <div class="marker-popover">
        <button type="button" class="marker-remove-btn" aria-label="حذف النقطة" onclick="removeConversionMarker()">حذف</button>
        <div class="marker-popover-body">${safeBody}</div>
      </div>
    `;
  }

  function updateBasemapToggleLabel() {
    const toggleBtn = document.getElementById('basemapToggle');
    const nextMenuItem = document.getElementById('nextBasemapMenuItem');
    if(!toggleBtn) {
      return;
    }
    const current = basemapConfigs[currentBasemapIndex];
    const next = basemapConfigs[(currentBasemapIndex + 1) % basemapConfigs.length];
    toggleBtn.textContent = ` ( الانتقال إلى ${next.label})`;
    toggleBtn.setAttribute('aria-label', `التبديل من ${current.label} إلى ${next.label}`);
    toggleBtn.setAttribute('aria-pressed', current.key === 'imagery' ? 'true' : 'false');
    if(nextMenuItem) {
      nextMenuItem.textContent = ` ( الانتقال إلى ${next.label})`;
    }
  }

  function updateConversionMarker(latitude, longitude, labelText, zoomLevel = 14) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!conversionMarker) {
      conversionMarker = L.circleMarker(target, {
        radius: 10,
        color: '#1f6de2',
        fillColor: '#1f6de2',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      conversionMarker.setLatLng(target);
    }
    const popupHtml = getConversionMarkerPopupHtml(labelText);
    conversionMarker.bindPopup(popupHtml).openPopup();
    mapInstance.setView(target, zoomLevel);
  }

  function removeConversionMarker() {
    if(conversionMarker && mapInstance) {
      mapInstance.removeLayer(conversionMarker);
      conversionMarker = null;
    }
    if(mapInstance) {
      mapInstance.closePopup();
    }
  }

  function updateUserLocationMarker(latitude, longitude, labelText, zoomLevel = 16) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!userMarker) {
      userMarker = L.circleMarker(target, {
        radius: 10,
        color: '#1fa86d',
        fillColor: '#1fa86d',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      userMarker.setLatLng(target);
    }
    if(labelText) {
      userMarker.bindPopup(labelText).openPopup();
    }
    mapInstance.setView(target, zoomLevel);
  }

  function handleMapClick(event) {
    if(!manualPointSelectionArmed || !event || !event.latlng) {
      return;
    }
    const latitude = event.latlng.lat;
    const longitude = event.latlng.lng;
    setManualPointSelectionState(false);
    setDmsInputsFromDecimal(latitude, longitude);
    const latText = formatDMS(decimalToDMS(latitude, true));
    const lonText = formatDMS(decimalToDMS(longitude, false));
    updateConversionMarker(latitude, longitude, `نقطة محددة يدويًا<br>${wrapDmsHtml(latText, lonText)}`);
    const conversionTypeElement = document.getElementById('conversionType');
    if(conversionTypeElement && conversionTypeElement.value === 'latlong-to-Merchich') {
      convertSingle();
    }
  }

  function locateUser() {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    if(!navigator.geolocation) {
      alert('GPS غير مدعوم في هذا المتصفح');
      return;
    }

    stopGeoWatch();
    coarseLocationWarned = false;
    const geoOptions = {
      enableHighAccuracy: true,
      timeout: 15000,
      maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy === null || accuracy > 120) {
          startGeoWatch(geoOptions);
        }
      },
      (error) => {
        handleUserLocationError(error);
      },
      geoOptions
    );
  }

  function handleUserLocationSuccess(position) {
    const latitude = position.coords.latitude;
    const longitude = position.coords.longitude;
    const accuracy = Number.isFinite(position.coords.accuracy) ? Math.round(position.coords.accuracy) : null;
    const latDmsText = formatDMS(decimalToDMS(latitude, true));
    const lonDmsText = formatDMS(decimalToDMS(longitude, false));
    const popupHeader = accuracy !== null
      ? `Ma position actuelle (±${accuracy} m)`
      : 'Ma position actuelle';
    const popupText = `${popupHeader}<br>${wrapDmsHtml(latDmsText, lonDmsText)}`;

    updateUserLocationMarker(latitude, longitude, popupText, 16);

    if(accuracy !== null && Number.isFinite(accuracy)) {
      const circleTarget = [latitude, longitude];
      if(!userAccuracyCircle) {
        userAccuracyCircle = L.circle(circleTarget, {
          radius: accuracy,
          color: '#1fa86d',
          fillColor: '#1fa86d',
          fillOpacity: 0.15,
          weight: 1
        }).addTo(mapInstance);
      } else {
        userAccuracyCircle.setLatLng(circleTarget);
        userAccuracyCircle.setRadius(accuracy);
      }
    } else if(userAccuracyCircle) {
      mapInstance.removeLayer(userAccuracyCircle);
      userAccuracyCircle = null;
    }

    if(accuracy !== null && accuracy > 10000 && !coarseLocationWarned) {
      alert('تم الحصول على موقع تقريبي فقط. الرجاء تفعيل GPS أو الاتصال بشبكة Wi-Fi للحصول على دقة أعلى.');
      coarseLocationWarned = true;
    }

    return accuracy;
  }

  function handleUserLocationError(error) {
    stopGeoWatch();
    if(error && error.code === error.PERMISSION_DENIED) {
      alert('تم رفض إذن الموقع');
      return;
    }
    if(error && error.code === error.POSITION_UNAVAILABLE) {
      alert('تعذر تحديد موقعك. تأكد من تفعيل GPS أو خدمات الموقع ثم أعد المحاولة.');
      return;
    }
    if(error && error.code === error.TIMEOUT) {
      alert('انتهت مهلة الحصول على الموقع. حاول مرة أخرى بعد التأكد من تفعيل GPS.');
      return;
    }
    alert('تعذر الحصول على الموقع الحالي');
  }

  function startGeoWatch(options) {
    if(typeof navigator.geolocation.watchPosition !== 'function') {
      return;
    }
    stopGeoWatch();
    geoWatchId = navigator.geolocation.watchPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy !== null && accuracy <= 60) {
          stopGeoWatch();
        }
      },
      (error) => {
        stopGeoWatch();
        handleUserLocationError(error);
      },
      options
    );

    geoWatchTimeoutId = window.setTimeout(() => {
      stopGeoWatch();
    }, 20000);
  }

  function stopGeoWatch() {
    if(geoWatchId !== null) {
      navigator.geolocation.clearWatch(geoWatchId);
      geoWatchId = null;
    }
    if(geoWatchTimeoutId) {
      clearTimeout(geoWatchTimeoutId);
      geoWatchTimeoutId = null;
    }
  }

  function updateFileHint() {
    const type = document.getElementById('conversionType').value;
    const hint = document.getElementById('fileHint');
    const manualHint = document.getElementById('manualHint');
    const csvImage = document.getElementById('csvModelImage');
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const batchSection = document.getElementById('batchSection');
    toggleManualFields(type);

    if(type === 'latlong-to-Merchich') {
      const disabledMsg = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S''). الرجاء استخدام التحويل اليدوي لهذا الاتجاه.";
      if(hint) {
        hint.dataset.defaultMessage = disabledMsg;
        hint.innerText = disabledMsg;
      }
      manualHint.innerText = "أدخل خطوط الطول والعرض (D°M'S'') ليتم تحويلها إلى إحداثيات X و Y باستخدام المنطقة المناسبة.";
      if(batchSection) batchSection.style.display = 'none';
      if(csvImage) {
        csvImage.style.display = 'none';
      }
      if(fileInput) {
        fileInput.value = '';
        fileInput.disabled = true;
      }
      if(convertBtn) convertBtn.disabled = true;
      if(downloadBtn) downloadBtn.disabled = true;
      lastConvertedRows = [];
      lastConvertedFields = null;
    } else {
      const activeMsg = "ارفع ملف CSV (أعمدة X و Y) بحجم لا يتجاوز 1 ميغابايت وبعدد أسطر لا يتخطى 200 ليتم تحويله إلى Lat/Long (D°M'S'').";
      if(hint) {
        hint.dataset.defaultMessage = activeMsg;
        hint.innerText = activeMsg;
      }
      manualHint.innerText = "أدخل إحداثيات (X, Y) يدويًا ليتم تحويلها مباشرة إلى Lat/Long باستخدام المنطقة المناسبة.";
      if(batchSection) batchSection.style.display = 'block';
      if(csvImage) {
        csvImage.src = 'modelcsvxy.JPG';
        csvImage.style.display = 'block';
      }
      if(fileInput) fileInput.disabled = false;
      updateConvertButtonState();
    }
  }

  function toggleManualFields(type) {
    const dmsFields = document.getElementById('dmsFields');
    const cartesianFields = document.getElementById('cartesianFields');
    if(type === "latlong-to-Merchich") {
      dmsFields.style.display = 'flex';
      cartesianFields.style.display = 'none';
    } else {
      dmsFields.style.display = 'none';
      cartesianFields.style.display = 'flex';
    }
  }

  function dmsToDecimal(deg, min, sec, hemisphere) {
    if(isNaN(deg) || isNaN(min) || isNaN(sec)) {
      return NaN;
    }
    const absValue = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const hemisphereSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    const degreeSign = deg < 0 ? -1 : 1;
    return absValue * hemisphereSign * degreeSign;
  }

  function decimalToDMS(value, isLatitude) {
    if(isNaN(value)) return null;
    const absValue = Math.abs(value);
    const degrees = Math.floor(absValue);
    const minutesFloat = (absValue - degrees) * 60;
    const minutes = Math.floor(minutesFloat);
    const seconds = (minutesFloat - minutes) * 60;
    const hemisphere = isLatitude
      ? (value < 0 ? 'S' : 'N')
      : (value < 0 ? 'W' : 'E');
    return { degrees, minutes, seconds, hemisphere, isLatitude };
  }

  function padTwoDigits(value) {
    return value < 10 ? `0${value}` : `${value}`;
  }

  function padSeconds(seconds) {
    const str = seconds.toFixed(2);
    return seconds < 10 ? `0${str}` : str;
  }

  function setDmsInputsFromDecimal(latitude, longitude) {
    const latDms = decimalToDMS(latitude, true);
    const lonDms = decimalToDMS(longitude, false);
    applyDmsToInputs('lat', latDms);
    applyDmsToInputs('lon', lonDms);
    setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
    validateGeographicInputs();
  }

  function applyDmsToInputs(prefix, dms) {
    if(!dms) {
      return;
    }
    const degreeInput = document.getElementById(`${prefix}Deg`);
    if(degreeInput) {
      degreeInput.value = padTwoDigits(dms.degrees);
    }
    const minuteInput = document.getElementById(`${prefix}Min`);
    if(minuteInput) {
      minuteInput.value = padTwoDigits(dms.minutes);
    }
    const secondInput = document.getElementById(`${prefix}Sec`);
    if(secondInput) {
      secondInput.value = padSeconds(dms.seconds);
    }
    const hemisphereSelect = document.getElementById(`${prefix}Hemisphere`);
    if(hemisphereSelect) {
      hemisphereSelect.value = dms.hemisphere;
    }
  }

  function enforceNumericCharacters(input, options = {}) {
    if(!input) {
      return '';
    }
    const {
      allowDecimal = false,
      allowNegative = false,
      maxLength = null,
      decimalSeparatorReplacement = null
    } = options;
    const rawValue = input.value || '';
    let sanitized = '';
    let decimalUsed = false;
    let decimalChar = null;

    for(let index = 0; index < rawValue.length; index++) {
      const char = rawValue[index];
      if(char >= '0' && char <= '9') {
        sanitized += char;
        continue;
      }
      if(allowDecimal && (char === '.' || char === ',')) {
        if(decimalUsed) {
          continue;
        }
        sanitized += char;
        decimalUsed = true;
        decimalChar = char;
        continue;
      }
      if(allowNegative && char === '-' && sanitized.length === 0) {
        sanitized = '-';
      }
    }

    if(!allowNegative) {
      sanitized = sanitized.replace(/-/g, '');
    } else if(sanitized.indexOf('-') > 0) {
      sanitized = sanitized.replace(/-/g, '');
      sanitized = `-${sanitized}`;
    }

    if(typeof maxLength === 'number' && maxLength > 0 && !allowDecimal) {
      const isNegative = allowNegative && sanitized.startsWith('-');
      const limit = maxLength + (isNegative ? 1 : 0);
      sanitized = sanitized.slice(0, limit);
    }

    if(!allowDecimal) {
      sanitized = sanitized.replace(/[.,]/g, '');
    } else if(decimalSeparatorReplacement && decimalChar && decimalChar !== decimalSeparatorReplacement) {
      const decimalIndex = sanitized.indexOf(decimalChar);
      if(decimalIndex !== -1) {
        sanitized = sanitized.slice(0, decimalIndex) + decimalSeparatorReplacement + sanitized.slice(decimalIndex + 1);
      }
    }

    if(input.value !== sanitized) {
      input.value = sanitized;
    }
    return sanitized;
  }

  function enforceTwoDigits(input) {
    enforceNumericCharacters(input, { maxLength: 2 });
  }

  function sanitizeSeconds(input) {
    enforceNumericCharacters(input, { allowDecimal: true });
  }

  function finalizeSeconds(input) {
    let value = input.value.trim();
    if(value === '') return;
    const usesComma = value.includes(',');
    const usesDot = value.includes('.');
    const normalized = value.replace(',', '.');
    let num = parseFloat(normalized);
    if(isNaN(num)) {
      input.value = '';
      return;
    }
    num = Math.min(59.99, Math.max(0, num));
    if(usesComma || usesDot) {
      const truncated = Math.floor(num * 100) / 100;
      let str = truncated.toFixed(2);
      if(usesComma && !usesDot) {
        str = str.replace('.', ',');
      }
      input.value = str;
    } else {
      input.value = Math.round(num).toString();
    }
  }

  function readSecondsValue(elementId) {
    const raw = document.getElementById(elementId).value.trim();
    if(raw === '') return NaN;
    const normalized = raw.replace(',', '.');
    const num = parseFloat(normalized);
    if(isNaN(num)) return NaN;
    const clamped = Math.min(59.99, Math.max(0, num));
    return Math.floor(clamped * 100) / 100;
  }

  function areInputsFilled(inputIds) {
    return inputIds.every((id) => {
      const element = document.getElementById(id);
      return element && element.value.trim() !== '';
    });
  }

  function setInputsValidity(inputIds, { reset = false, isValid = true, message = '' } = {}) {
    inputIds.forEach((id) => {
      const element = document.getElementById(id);
      if(!element) {
        return;
      }
      if(reset) {
        element.classList.remove('is-invalid');
        element.removeAttribute('aria-invalid');
        element.removeAttribute('title');
        return;
      }
      if(isValid) {
        element.classList.remove('is-invalid');
        element.removeAttribute('aria-invalid');
        element.removeAttribute('title');
        return;
      }
      element.classList.add('is-invalid');
      element.setAttribute('aria-invalid', 'true');
      if(message) {
        element.setAttribute('title', message);
      } else {
        element.removeAttribute('title');
      }
    });
  }

  function getZoneKeyForLatitude(latitude) {
    if(!Number.isFinite(latitude)) {
      return null;
    }
    for(const [zoneKey, limits] of Object.entries(zoneValidationLimits)) {
      const range = limits.latRange;
      if(range && latitude >= range.min && latitude <= range.max) {
        return zoneKey;
      }
    }
    return null;
  }

  function isPointInsideMorocco(longitude, latitude) {
    const geometry = MOROCCO_BOUNDARY.geometry || MOROCCO_BOUNDARY;
    if(!geometry || !geometry.coordinates) {
      return false;
    }
    const polygons = geometry.type === 'MultiPolygon'
      ? geometry.coordinates
      : [geometry.coordinates];
    for(const polygon of polygons) {
      if(isPointInsidePolygonRings(longitude, latitude, polygon)) {
        return true;
      }
    }
    return false;
  }

  function isPointInsidePolygonRings(longitude, latitude, rings) {
    if(!Array.isArray(rings) || !rings.length) {
      return false;
    }
    if(!isPointInRing(longitude, latitude, rings[0])) {
      return false;
    }
    for(let i = 1; i < rings.length; i++) {
      if(isPointInRing(longitude, latitude, rings[i])) {
        return false;
      }
    }
    return true;
  }

  function isPointInRing(longitude, latitude, ring) {
    if(!Array.isArray(ring) || ring.length < 4) {
      return false;
    }
    let inside = false;
    for(let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      const xi = ring[i][0];
      const yi = ring[i][1];
      const xj = ring[j][0];
      const yj = ring[j][1];
      const intersects = ((yi > latitude) !== (yj > latitude))
        && (longitude < (xj - xi) * (latitude - yi) / ((yj - yi) || 1e-12) + xi);
      if(intersects) {
        inside = !inside;
      }
    }
    return inside;
  }

  function getDomainErrorMessage(errorType) {
    if(errorType === 'morocco') {
      return MOROCCO_DOMAIN_ERROR_TEXT;
    }
    if(errorType === 'zones') {
      return ZONE_RANGE_ERROR_TEXT;
    }
    return 'تعذر تحديد المجال الجغرافي للنقطة.';
  }

  function formatZoneMismatchMessage(actualZoneKey, selectedZoneKey) {
    const actualLabel = getZoneDisplayLabel(actualZoneKey) || actualZoneKey || 'منطقة غير معروفة';
    const selectedLabel = getZoneDisplayLabel(selectedZoneKey) || selectedZoneKey || 'منطقة غير محددة';
    return ZONE_MISMATCH_WARNING_TEMPLATE
      .replace('{actualZone}', actualLabel)
      .replace('{selectedZone}', selectedLabel);
  }

  function resolveZoneAlignment(actualZoneKey, { requireConfirmation = true } = {}) {
    if(!actualZoneKey) {
      return { proceed: false, zoneKey: null, warning: null };
    }

    const hasUserPreference = Boolean(selectedCityName);
    const updateActiveZone = () => {
      setActiveZone(actualZoneKey);
      updateCityZoneBadge(getZoneDisplayLabel(actualZoneKey));
    };

    if(!hasUserPreference) {
      if(currentZoneKey !== actualZoneKey) {
        updateActiveZone();
      }
      return { proceed: true, zoneKey: actualZoneKey, warning: null };
    }

    if(currentZoneKey === actualZoneKey) {
      updateActiveZone();
      return { proceed: true, zoneKey: actualZoneKey, warning: null };
    }

    const warning = formatZoneMismatchMessage(actualZoneKey, currentZoneKey);
    if(!requireConfirmation) {
      return { proceed: true, zoneKey: actualZoneKey, warning };
    }

    const actualLabel = getZoneDisplayLabel(actualZoneKey) || actualZoneKey;
    const confirmMessage = `${warning}\nهل تريد المتابعة باستخدام ${actualLabel}؟`;
    const accepted = typeof window !== 'undefined'
      && typeof window.confirm === 'function'
        ? window.confirm(confirmMessage)
        : true;
    if(!accepted) {
      return { proceed: false, zoneKey: null, warning };
    }
    updateActiveZone();
    return { proceed: true, zoneKey: actualZoneKey, warning };
  }

  function convertPlanarToWgs84Auto(x, y) {
    let fallbackReason = null;
    let fallbackCandidate = null;
    for(const [zoneKey, zoneConfig] of Object.entries(merchichZones)) {
      if(!zoneConfig || !zoneConfig.proj) {
        continue;
      }
      let lon;
      let lat;
      try {
        [lon, lat] = proj4(zoneConfig.proj, wgs84, [x, y]);
      } catch (error) {
        continue;
      }
      if(!Number.isFinite(lat) || !Number.isFinite(lon)) {
        continue;
      }
      if(!isPointInsideMorocco(lon, lat)) {
        fallbackReason = fallbackReason || 'morocco';
        continue;
      }
      const inferredZoneKey = getZoneKeyForLatitude(lat);
      if(!inferredZoneKey) {
        fallbackReason = fallbackReason || 'zones';
        continue;
      }
      const candidate = {
        status: 'ok',
        lon,
        lat,
        inferredZoneKey,
        sourceZoneKey: zoneKey
      };
      if(inferredZoneKey === zoneKey) {
        return candidate;
      }
      if(!fallbackCandidate) {
        fallbackCandidate = candidate;
      }
    }
    if(fallbackCandidate) {
      return fallbackCandidate;
    }
    return { status: 'error', errorType: fallbackReason || 'invalid' };
  }

  function getDmsDecimal(prefix) {
    const deg = parseFloat(document.getElementById(`${prefix}Deg`).value);
    const min = parseFloat(document.getElementById(`${prefix}Min`).value);
    const sec = readSecondsValue(`${prefix}Sec`);
    const hemisphereElement = document.getElementById(`${prefix}Hemisphere`);
    const hemisphere = hemisphereElement ? hemisphereElement.value : (prefix === 'lat' ? 'N' : 'E');
    return dmsToDecimal(deg, min, sec, hemisphere);
  }

  function validateGeographicInputs() {
    const conversionType = document.getElementById('conversionType').value;
    if(conversionType !== 'latlong-to-Merchich') {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'skipped' };
    }

    if(!areInputsFilled(GEO_COORD_INPUT_IDS)) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'incomplete' };
    }

    const latValue = getDmsDecimal('lat');
    const lonValue = getDmsDecimal('lon');
    if(!Number.isFinite(latValue) || !Number.isFinite(lonValue)) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'invalid-input' };
    }

    setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
    return { status: 'validated', latValue, lonValue };
  }

  function resetPlanarValidity() {
    setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
  }

  function validateAllCoordinateGroups() {
    validateGeographicInputs();
    resetPlanarValidity();
  }

  function formatDMS(dms) {
    if(!dms) return '';
    const degreeWidth = dms.isLatitude ? 2 : 3;
    const degreeStr = dms.degrees.toString().padStart(degreeWidth, '0');
    const minuteStr = padTwoDigits(dms.minutes);
    const secondStr = padSeconds(dms.seconds);
    return `${degreeStr}° ${minuteStr}' ${secondStr}" ${dms.hemisphere}`;
  }

  function wrapDmsHtml(latText, lonText) {
    const safeLat = latText || '';
    const safeLon = lonText || '';
    return `<span class="dms-popup">${safeLat}<br>${safeLon}</span>`;
  }

  function normalizeDmsString(value) {
    return value.toString()
      .replace(/,/g, '.')
      .replace(/″|”|“/g, '"')
      .replace(/′|’|`/g, "'")
      .replace(/º|˚/g, '°')
      .trim();
  }

  function parseCsvDms(value, hemisphere) {
    if(value === undefined || value === null) return NaN;
    const normalized = normalizeDmsString(value);
    const cleaned = normalized
      .replace(/[NSEW]\s*$/i, '')
      .replace(/"/g, '')
      .trim();
    const regex = /(-?\d+(?:\.\d+)?)\s*°\s*(\d+(?:\.\d+)?)\s*['′’]\s*(\d+(?:\.\d+)?)/;
    const match = cleaned.match(regex);
    if(!match) return NaN;
    const deg = parseFloat(match[1]);
    const min = parseFloat(match[2]);
    const sec = parseFloat(match[3]);
    const base = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const degreeSign = deg < 0 ? -1 : 1;
    const hemiSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    return base * degreeSign * hemiSign;
  }

  function getCsvField(row, targetKey) {
    const normalizedTarget = normalizeKeyName(targetKey);
    for (const key in row) {
      if(!Object.prototype.hasOwnProperty.call(row, key)) continue;
      if(typeof key !== 'string') continue;
      if(normalizeKeyName(key) === normalizedTarget) {
        return row[key];
      }
    }
    return undefined;
  }

  function hasField(fields, targetKey) {
    if(!Array.isArray(fields)) return false;
    const normalizedKey = normalizeKeyName(targetKey);
    return fields.some(field => {
      if(field === undefined || field === null) return false;
      return normalizeKeyName(field) === normalizedKey;
    });
  }

  function normalizeKeyName(key) {
    if(key === undefined || key === null) return '';
    return key.toString().replace(/\ufeff/g, '').trim().toLowerCase();
  }

  function updateConvertButtonState() {
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const type = document.getElementById('conversionType').value;
    if(!convertBtn || !fileInput) return;
    if(type !== 'Merchich-to-latlong') {
      convertBtn.disabled = true;
      return;
    }
    const file = fileInput.files[0];
    const isValidSize = file ? file.size <= MAX_FILE_SIZE_BYTES : false;
    convertBtn.disabled = !isValidSize;
  }

  function handleCsvFileChange() {
    const fileInput = document.getElementById('csvFile');
    const hint = document.getElementById('fileHint');
    if(!fileInput) return;
    const file = fileInput.files[0];
    if(file && file.size > MAX_FILE_SIZE_BYTES) {
      const sizeMb = (file.size / (1024 * 1024)).toFixed(2);
      if(hint) {
        hint.innerText = `حجم الملف ${sizeMb} ميغابايت وهو أكبر من الحد المسموح (1 ميغابايت). اختر ملفًا أصغر ثم أعد المحاولة.`;
      }
      fileInput.value = '';
    } else if(hint && hint.dataset.defaultMessage) {
      hint.innerText = hint.dataset.defaultMessage;
    }

    updateConvertButtonState();
    lastConvertedRows = [];
    lastConvertedFields = null;
    const downloadBtn = document.getElementById('downloadBtn');
    if(downloadBtn) downloadBtn.disabled = true;
  }

  function normalizeZoneKey(zoneValue) {
    if(typeof zoneValue !== 'string') {
      return '';
    }
    return zoneValue
      .trim()
      .replace(/\s+/g, '_')
      .replace(/-+/g, '_')
      .replace(/zone/gi, 'Zone');
  }

  function getZoneDisplayLabel(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    const zoneConfig = merchichZones[normalized];
    if(zoneConfig && zoneConfig.label) {
      return zoneConfig.label;
    }
    return normalized ? normalized.replace(/_/g, ' ') : '';
  }

  function getCurrentZoneConfig() {
    return merchichZones[currentZoneKey] || merchichZones[defaultZoneKey] || null;
  }

  function setActiveZone(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    if(normalized && merchichZones[normalized]) {
      currentZoneKey = normalized;
    } else {
      currentZoneKey = defaultZoneKey;
    }
  }

  function initManualNumericFields() {
    const manualNumericInputs = [
      { id: 'manualX', options: { allowDecimal: true, decimalSeparatorReplacement: '.' } },
      { id: 'manualY', options: { allowDecimal: true, decimalSeparatorReplacement: '.' } }
    ];

    manualNumericInputs.forEach(({ id, options }) => {
      const element = document.getElementById(id);
      if(!element) {
        return;
      }
      const handler = () => {
        enforceNumericCharacters(element, options);
        resetPlanarValidity();
      };
      element.addEventListener('input', handler);
      element.addEventListener('blur', handler);
    });
  }

  function initDmsValidationListeners() {
    const registerGroup = (ids, callback) => {
      ids.forEach((id) => {
        const element = document.getElementById(id);
        if(!element) {
          return;
        }
        element.addEventListener('input', callback);
        element.addEventListener('blur', callback);
      });
    };
    registerGroup(LAT_INPUT_IDS, () => validateGeographicInputs());
    registerGroup(LON_INPUT_IDS, () => validateGeographicInputs());
    const latHem = document.getElementById('latHemisphere');
    if(latHem) {
      latHem.addEventListener('change', () => validateGeographicInputs());
    }
    const lonHem = document.getElementById('lonHemisphere');
    if(lonHem) {
      lonHem.addEventListener('change', () => validateGeographicInputs());
    }
  }


  function flattenCityZones(cityData) {
    const flattened = {};
    if(!cityData || typeof cityData !== 'object') {
      return flattened;
    }
    Object.entries(cityData).forEach(([key, value]) => {
      if(Array.isArray(value)) {
        const zoneKey = normalizeZoneKey(key);
        if(!zoneKey) {
          return;
        }
        value.forEach((cityName) => {
          if(typeof cityName !== 'string') {
            return;
          }
          const trimmed = cityName.trim();
          if(!trimmed) {
            return;
          }
          flattened[trimmed] = zoneKey;
        });
        return;
      }
      if(typeof value === 'string') {
        const zoneKey = normalizeZoneKey(value);
        if(!zoneKey) {
          return;
        }
        const trimmedKey = typeof key === 'string' ? key.trim() : key;
        if(!trimmedKey) {
          return;
        }
        flattened[trimmedKey] = zoneKey;
      }
    });
    return flattened;
  }

  function getCityDisplayLabel(name) {
    if(!name) {
      return '';
    }
    const match = cityOptionsCache.find((entry) => entry.name === name);
    return match ? match.display : '';
  }

  function getCityEntryByName(name) {
    if(!name) {
      return null;
    }
    return cityOptionsCache.find((entry) => entry.name === name) || null;
  }

  function clearSelectedCityState() {
    selectedCityName = '';
    setActiveZone('');
    updateCityZoneBadge('');
    validateAllCoordinateGroups();
  }

  function commitCitySelection(entry) {
    if(!entry) {
      clearSelectedCityState();
      hideCitySuggestionsList();
      return;
    }
    selectedCityName = entry.name;
    const normalizedZone = normalizeZoneKey(entry.zoneKey);
    const zoneLabel = normalizedZone ? getZoneDisplayLabel(normalizedZone) : '';
    setActiveZone(normalizedZone);
    updateCityZoneBadge(zoneLabel);
    const searchInput = document.getElementById('citySearchInput');
    if(searchInput) {
      const displayValue = entry.display || entry.name;
      searchInput.value = displayValue;
      if(typeof searchInput.setSelectionRange === 'function') {
        const cursorPos = displayValue.length;
        searchInput.setSelectionRange(cursorPos, cursorPos);
      }
    }
    hideCitySuggestionsList();
    validateAllCoordinateGroups();
    syncCityClearButtonVisibility();
  }

  function updateCitySearchInputUI({ disabled = false, placeholderText } = {}) {
    const searchInput = document.getElementById('citySearchInput');
    if(!searchInput) {
      return;
    }
    const placeholder = placeholderText || (disabled ? 'قائمة المدن غير متاحة' : 'ابحث عن المدينة');
    searchInput.placeholder = placeholder;
    if(disabled) {
      searchInput.value = '';
      searchInput.setAttribute('disabled', 'true');
      syncCityClearButtonVisibility();
      return;
    }
    searchInput.removeAttribute('disabled');
    if(selectedCityName && !searchInput.matches(':focus')) {
      const label = getCityDisplayLabel(selectedCityName) || selectedCityName;
      searchInput.value = label;
    }
    syncCityClearButtonVisibility();
  }

  // Restrict city search input to alphabetic characters and spaces
  function sanitizeCitySearchValueWithCaret(value, caretPosition) {
    if(typeof value !== 'string') {
      return { sanitizedValue: '', nextCaret: 0 };
    }
    let sanitizedValue = '';
    let nextCaret = typeof caretPosition === 'number' ? caretPosition : value.length;
    for(let index = 0; index < value.length; index++) {
      const char = value[index];
      if(CITY_ALLOWED_CHAR_REGEX.test(char)) {
        sanitizedValue += char;
      } else if(index < nextCaret) {
        nextCaret--;
      }
    }
    nextCaret = Math.max(0, Math.min(nextCaret, sanitizedValue.length));
    return { sanitizedValue, nextCaret };
  }

  function enforceCitySearchAlphaOnly(inputElement) {
    if(!inputElement) {
      return '';
    }
    const rawValue = inputElement.value || '';
    const caretPosition = typeof inputElement.selectionStart === 'number'
      ? inputElement.selectionStart
      : rawValue.length;
    const { sanitizedValue, nextCaret } = sanitizeCitySearchValueWithCaret(rawValue, caretPosition);
    if(rawValue !== sanitizedValue) {
      inputElement.value = sanitizedValue;
      if(typeof inputElement.setSelectionRange === 'function') {
        inputElement.setSelectionRange(nextCaret, nextCaret);
      }
    }
    return inputElement.value;
  }

  function handleCitySearchBeforeInput(event) {
    if(!event || typeof event.data !== 'string') {
      return;
    }
    if(event.data && !CITY_ALLOWED_TEXT_REGEX.test(event.data)) {
      event.preventDefault();
    }
  }

  function renderCitySuggestions(filterText = '', forceOpen = false) {
    if(!cityOptionsCache.length) {
      hideCitySuggestionsList();
      return;
    }
    const normalized = filterText.trim().toLowerCase();
    const matches = cityOptionsCache.filter((entry) => {
      if(!normalized) {
        return true;
      }
      return entry.name.toLowerCase().startsWith(normalized) || entry.display.toLowerCase().startsWith(normalized);
    }).slice(0, CITY_SUGGESTION_LIMIT);
    const shouldOpen = forceOpen || isCitySearchInputFocused();
    updateCitySuggestionList(matches, normalized, shouldOpen);
  }

  function isCitySearchInputFocused() {
    const input = document.getElementById('citySearchInput');
    return Boolean(input && document.activeElement === input);
  }

  function updateCitySuggestionList(matches, normalizedFilter, shouldOpen) {
    const listElement = document.getElementById('citySuggestionsList');
    if(!listElement) {
      syncCitySearchExpandedState(false);
      return;
    }
    listElement.innerHTML = '';
    if(!shouldOpen) {
      listElement.hidden = true;
      syncCitySearchExpandedState(false);
      return;
    }
    if(!matches.length) {
      if(normalizedFilter) {
        const emptyState = document.createElement('div');
        emptyState.className = 'city-suggestion-empty';
        emptyState.textContent = 'لا توجد مدينة مطابقة';
        listElement.appendChild(emptyState);
        listElement.hidden = false;
        syncCitySearchExpandedState(true);
      } else {
        listElement.hidden = true;
        syncCitySearchExpandedState(false);
      }
      return;
    }
    const fragment = document.createDocumentFragment();
    matches.forEach((entry) => {
      const optionButton = document.createElement('button');
      optionButton.type = 'button';
      optionButton.className = 'city-suggestion-item';
      optionButton.dataset.cityName = entry.name;
      optionButton.dataset.display = entry.display;
      optionButton.textContent = entry.display;
      optionButton.setAttribute('role', 'option');
      fragment.appendChild(optionButton);
    });
    listElement.appendChild(fragment);
    listElement.hidden = false;
    syncCitySearchExpandedState(true);
  }

  function hideCitySuggestionsList() {
    cancelCitySuggestionsHide();
    const listElement = document.getElementById('citySuggestionsList');
    if(listElement) {
      listElement.hidden = true;
      listElement.innerHTML = '';
    }
    syncCitySearchExpandedState(false);
  }

  function syncCitySearchExpandedState(isOpen) {
    const input = document.getElementById('citySearchInput');
    if(input) {
      input.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }
  }

  function syncCityClearButtonVisibility() {
    const input = document.getElementById('citySearchInput');
    const clearBtn = document.getElementById('citySearchClearBtn');
    if(!clearBtn) {
      return;
    }
    const isDisabled = Boolean(input && input.hasAttribute('disabled'));
    const hasValue = Boolean(input && input.value && input.value.trim().length);
    clearBtn.hidden = isDisabled || !hasValue;
  }

  function handleCitySearchClear() {
    const input = document.getElementById('citySearchInput');
    if(input) {
      input.value = '';
      input.focus();
    }
    clearSelectedCityState();
    hideCitySuggestionsList();
    syncCityClearButtonVisibility();
  }

  function findCityMatchByInput(inputValue) {
    const normalized = inputValue ? inputValue.trim().toLowerCase() : '';
    if(!normalized) {
      return null;
    }
    return cityOptionsCache.find((entry) => entry.display.toLowerCase() === normalized || entry.name.toLowerCase() === normalized)
      || cityOptionsCache.find((entry) => entry.display.toLowerCase().startsWith(normalized) || entry.name.toLowerCase().startsWith(normalized))
      || null;
  }

  function applyCitySelectionFromName(name) {
    commitCitySelection(getCityEntryByName(name));
  }

  function handleCitySearchInput(event) {
    if(!event || !event.target) {
      return;
    }
    const value = enforceCitySearchAlphaOnly(event.target);
    cancelCitySuggestionsHide();
    renderCitySuggestions(value, true);
    const match = findCityMatchByInput(value);
    const normalized = value.trim().toLowerCase();
    if(match && (match.display.toLowerCase() === normalized || match.name.toLowerCase() === normalized)) {
      applyCitySelectionFromName(match.name);
    } else {
      clearSelectedCityState();
    }
    syncCityClearButtonVisibility();
  }

  function handleCitySearchFocus() {
    cancelCitySuggestionsHide();
    const input = document.getElementById('citySearchInput');
    const value = input ? input.value : '';
    renderCitySuggestions(value, true);
    syncCityClearButtonVisibility();
  }

  function handleCitySearchKeyDown(event) {
    if(event.key === 'Escape') {
      hideCitySuggestionsList();
      return;
    }
    if(event.key === 'Enter') {
      const match = findCityMatchByInput(event.target.value || '');
      if(match) {
        event.preventDefault();
        applyCitySelectionFromName(match.name);
      }
    }
  }

  function cancelCitySuggestionsHide() {
    if(citySuggestionsHideTimeoutId) {
      clearTimeout(citySuggestionsHideTimeoutId);
      citySuggestionsHideTimeoutId = null;
    }
  }

  function handleCitySearchBlur() {
    cancelCitySuggestionsHide();
    citySuggestionsHideTimeoutId = window.setTimeout(() => {
      const listElement = document.getElementById('citySuggestionsList');
      const searchInput = document.getElementById('citySearchInput');
      const activeElement = document.activeElement;
      if(activeElement && (activeElement === searchInput || (listElement && listElement.contains(activeElement)))) {
        return;
      }
      hideCitySuggestionsList();
    }, 120);
  }

  function handleCitySuggestionClick(event) {
    const target = event.target.closest('.city-suggestion-item');
    if(!target) {
      return;
    }
    const cityName = target.dataset.cityName;
    if(!cityName) {
      return;
    }
    applyCitySelectionFromName(cityName);
  }

  function handleOutsideCitySuggestionClick(event) {
    if(event.target.closest('.city-search-wrapper')) {
      return;
    }
    hideCitySuggestionsList();
  }

  function initCityPicker() {
    if(typeof fetch !== 'function') {
      return;
    }
    fetch('ville.json', { cache: 'no-store' })
      .then((response) => {
        if(!response.ok) {
          throw new Error('Failed to load cities');
        }
        return response.json();
      })
      .then(populateCityOptions)
      .catch(handleCityLoadError);
  }

  function populateCityOptions(cityData) {
    const flattened = flattenCityZones(cityData);
    const entries = Object.entries(flattened);
    if(!entries.length) {
      cityOptionsCache = [];
      clearSelectedCityState();
      updateCitySearchInputUI({ disabled: true, placeholderText: 'لا توجد مدن متاحة' });
      hideCitySuggestionsList();
      return;
    }
    cityOptionsCache = entries.map(([name, zoneKey]) => {
      const zoneLabel = getZoneDisplayLabel(zoneKey);
      return {
        name,
        zoneKey,
        display: zoneLabel ? `${name} — ${zoneLabel}` : name
      };
    }).sort((a, b) => a.name.localeCompare(b.name, 'ar', { sensitivity: 'base', numeric: true }));

    if(selectedCityName && !getCityEntryByName(selectedCityName)) {
      clearSelectedCityState();
    }

    updateCitySearchInputUI({ disabled: false });
    renderCitySuggestions('', false);
  }

  function handleCityLoadError() {
    cityOptionsCache = [];
    clearSelectedCityState();
    updateCitySearchInputUI({ disabled: true, placeholderText: 'تعذر تحميل المدن' });
    hideCitySuggestionsList();
  }

  function updateCityZoneBadge(zoneText) {
    const badge = document.getElementById('cityZoneBadge');
    if(!badge) return;
    if(!zoneText) {
      badge.textContent = '';
      badge.hidden = true;
      return;
    }
    badge.textContent = zoneText;
    badge.hidden = false;
  }


  function handleReload() {
    window.location.reload();
  }

  function setSingleResultCopyAvailability() {
    const resultDiv = document.getElementById('singleResult');
    const copyBtn = document.getElementById('copySingleResultBtn');
    if(!copyBtn || !resultDiv) {
      return;
    }
    copyBtn.disabled = resultDiv.innerText.trim().length === 0;
  }

  function fallbackCopyToClipboard(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'absolute';
    textarea.style.left = '-9999px';
    document.body.appendChild(textarea);
    textarea.select();
    let copied = false;
    try {
      copied = document.execCommand('copy');
    } catch (error) {
      copied = false;
    }
    document.body.removeChild(textarea);
    if(!copied) {
      alert('تعذر نسخ النتيجة تلقائيًا. الرجاء النسخ يدويًا.');
    }
  }

  function copySingleResult() {
    const resultDiv = document.getElementById('singleResult');
    if(!resultDiv) {
      return;
    }
    const text = resultDiv.innerText.trim();
    if(!text) {
      return;
    }
    if(navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
      navigator.clipboard.writeText(text).catch(() => fallbackCopyToClipboard(text));
    } else {
      fallbackCopyToClipboard(text);
    }
  }

  function convertCSV() {
    const file = document.getElementById('csvFile').files[0];
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('result');
    const downloadBtn = document.getElementById('downloadBtn');

    lastConvertedRows = [];
    lastConvertedFields = null;
    lastConversionType = null;
    if(downloadBtn) downloadBtn.disabled = true;

    if(type !== 'Merchich-to-latlong') {
      resultDiv.innerText = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S'').";
      return;
    }

    if(!file) {
      resultDiv.innerHTML = "Veuillez d'abord sélectionner un fichier CSV.";
      return;
    }

    if(file.size > MAX_FILE_SIZE_BYTES) {
      resultDiv.innerText = 'حجم الملف يتجاوز 1 ميغابايت المسموح بها. الرجاء اختيار ملف أصغر ثم إعادة المحاولة.';
      return;
    }

    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: 'greedy',
      complete: function(results) {
        const data = results.data || [];
        if(data.length > MAX_CSV_ROWS) {
          resultDiv.innerText = `عدد الأسطر ${data.length} ويتجاوز الحد المسموح به (${MAX_CSV_ROWS})، الرجاء تقليص الملف ثم إعادة المحاولة.`;
          return;
        }
        const fields = (results.meta && Array.isArray(results.meta.fields)) ? results.meta.fields : [];
        if(!hasField(fields, 'X') || !hasField(fields, 'Y')) {
          const existing = fields.length ? fields.join(', ') : 'بدون رؤوس واضحة';
          resultDiv.innerText = `لم يتم العثور على عمودين باسم X و Y. الأعمدة الحالية في الملف: ${existing}`;
          return;
        }

        const warnings = new Set();
        const convertedRows = [];
        let textOutput = 'الإحداثيات المحوّلة (عمود A = Latitude، عمود B = Longitude):\n\n';
        let domainError = null;

        data.forEach((row, index) => {
          if(domainError) {
            return;
          }
          const xVal = getCsvField(row, 'X');
          const yVal = getCsvField(row, 'Y');
          if(xVal === undefined || yVal === undefined) return;
          const x = parseFloat(xVal);
          const y = parseFloat(yVal);
          if(isNaN(x) || isNaN(y)) return;

          const conversion = convertPlanarToWgs84Auto(x, y);
          if(conversion.status !== 'ok') {
            domainError = {
              type: conversion.errorType || 'zones',
              message: getDomainErrorMessage(conversion.errorType || 'zones')
            };
            return;
          }

          const { lon, lat, inferredZoneKey } = conversion;
          const zoneResolution = resolveZoneAlignment(inferredZoneKey, { requireConfirmation: Boolean(selectedCityName) });
          if(!zoneResolution.proceed) {
            domainError = {
              type: 'user-abort',
              message: zoneResolution.warning || 'تم إيقاف التحويل بناءً على اختيار المستخدم.'
            };
            return;
          }
          if(zoneResolution.warning) {
            warnings.add(zoneResolution.warning);
          }

          const latDms = decimalToDMS(lat, true);
          const lonDms = decimalToDMS(lon, false);
          const latText = formatDMS(latDms);
          const lonText = formatDMS(lonDms);
          convertedRows.push({ Latitude: latText, Longitude: lonText });
          textOutput += `Ligne ${index + 1} : Latitude ${latText}, Longitude ${lonText}\n`;
        });

        if(domainError) {
          resultDiv.innerText = domainError.message;
          lastConvertedRows = [];
          lastConvertedFields = null;
          lastConversionType = null;
          if(downloadBtn) downloadBtn.disabled = true;
          return;
        }

        if(!convertedRows.length) {
          const attempted = data.length;
          resultDiv.innerText = `لم يتم العثور على صفوف صالحة للتحويل بعد فحص ${attempted} صفًا. تأكد من أن كل صف يحتوي على قيم رقمية في عمودي X و Y.`;
          return;
        }

        const warningText = warnings.size
          ? Array.from(warnings).map((text) => `تحذير: ${text}`).join('\n') + '\n\n'
          : '';
        resultDiv.innerText = `${warningText}${textOutput}`;

        lastConvertedRows = convertedRows;
        lastConvertedFields = ['Latitude', 'Longitude'];
        lastConversionType = type;
        if(downloadBtn) downloadBtn.disabled = false;
      }
    });
  }


  function convertSingle() {
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('singleResult');
    const warnings = [];

    if(type === 'latlong-to-Merchich') {
      const geoValidation = validateGeographicInputs();
      if(geoValidation.status === 'incomplete') {
        resultDiv.innerText = 'الرجاء إدخال قيم كاملة للخطوط قبل التحويل.';
        setSingleResultCopyAvailability();
        return;
      }
      if(geoValidation.status === 'invalid-input') {
        resultDiv.innerText = "Veuillez saisir des degrés، minutes et secondes valides pour la latitude et la longitude.";
        setSingleResultCopyAvailability();
        return;
      }
      if(geoValidation.status !== 'validated') {
        resultDiv.innerText = 'لا يمكن التحقق من المدخلات الحالية. تحقق من القيم المدخلة ثم أعد المحاولة.';
        setSingleResultCopyAvailability();
        return;
      }

      const latitude = geoValidation.latValue;
      const longitude = geoValidation.lonValue;

      if(!isPointInsideMorocco(longitude, latitude)) {
        setInputsValidity(GEO_COORD_INPUT_IDS, { isValid: false, message: MOROCCO_DOMAIN_ERROR_TEXT });
        resultDiv.innerText = MOROCCO_DOMAIN_ERROR_TEXT;
        setSingleResultCopyAvailability();
        return;
      }

      const inferredZoneKey = getZoneKeyForLatitude(latitude);
      if(!inferredZoneKey) {
        setInputsValidity(GEO_COORD_INPUT_IDS, { isValid: false, message: ZONE_RANGE_ERROR_TEXT });
        resultDiv.innerText = ZONE_RANGE_ERROR_TEXT;
        setSingleResultCopyAvailability();
        return;
      }

      const zoneResolution = resolveZoneAlignment(inferredZoneKey, { requireConfirmation: Boolean(selectedCityName) });
      if(!zoneResolution.proceed) {
        resultDiv.innerText = zoneResolution.warning || 'تم إلغاء العملية بناءً على اختيار المستخدم.';
        setSingleResultCopyAvailability();
        return;
      }
      if(zoneResolution.warning) {
        warnings.push(zoneResolution.warning);
      }

      const zoneConfig = merchichZones[zoneResolution.zoneKey];
      if(!zoneConfig) {
        resultDiv.innerText = 'لا يوجد نظام إسقاط صالح متاح لهذه النقطة.';
        setSingleResultCopyAvailability();
        return;
      }

      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });

      const [xMerchich, yMerchich] = proj4(wgs84, zoneConfig.proj, [longitude, latitude]);
      const xInt = Math.round(xMerchich);
      const yInt = Math.round(yMerchich);
      const latDmsText = formatDMS(decimalToDMS(latitude, true));
      const lonDmsText = formatDMS(decimalToDMS(longitude, false));
      let output = `X = ${xInt}\nY = ${yInt}\nZone: ${getZoneDisplayLabel(zoneResolution.zoneKey) || zoneResolution.zoneKey}`;
      if(warnings.length) {
        output = `${warnings.join('\n')}\n\n${output}`;
      }
      resultDiv.innerText = output;
      setSingleResultCopyAvailability();
      updateConversionMarker(latitude, longitude, `الموقع الأصلي<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
      return;
    }

    const xInput = parseFloat(document.getElementById('manualX').value);
    const yInput = parseFloat(document.getElementById('manualY').value);

    if(isNaN(xInput) || isNaN(yInput)) {
      resultDiv.innerText = "Veuillez saisir des valeurs numériques valides pour X و Y.";
      setSingleResultCopyAvailability();
      return;
    }

    const planarConversion = convertPlanarToWgs84Auto(xInput, yInput);
    if(planarConversion.status !== 'ok') {
      const message = getDomainErrorMessage(planarConversion.errorType || 'zones');
      setInputsValidity(CARTESIAN_INPUT_IDS, { isValid: false, message });
      resultDiv.innerText = message;
      setSingleResultCopyAvailability();
      return;
    }

    const { lon, lat, inferredZoneKey } = planarConversion;
    const zoneResolution = resolveZoneAlignment(inferredZoneKey, { requireConfirmation: Boolean(selectedCityName) });
    if(!zoneResolution.proceed) {
      resultDiv.innerText = zoneResolution.warning || 'تم إلغاء العملية بناءً على اختيار المستخدم.';
      setSingleResultCopyAvailability();
      return;
    }
    if(zoneResolution.warning) {
      warnings.push(zoneResolution.warning);
    }

    setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
    const latDms = decimalToDMS(lat, true);
    const lonDms = decimalToDMS(lon, false);
    const latDmsText = formatDMS(latDms);
    const lonDmsText = formatDMS(lonDms);
    let output = `Latitude : ${latDmsText}\nLongitude : ${lonDmsText}`;
    if(warnings.length) {
      output = `${warnings.join('\n')}\n\n${output}`;
    }
    resultDiv.innerText = output;
    setSingleResultCopyAvailability();
    updateConversionMarker(lat, lon, `النقطة المحوّلة إلى Lat/Long<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
  }

  function downloadConvertedFile() {
    if(!lastConvertedRows.length) {
      alert('لا توجد نتائج متاحة للتحميل. الرجاء تنفيذ تحويل CSV أولاً.');
      return;
    }

    const unparseInput = lastConvertedFields ? { fields: lastConvertedFields, data: lastConvertedRows } : lastConvertedRows;
    const csvContent = Papa.unparse(unparseInput);
    const bom = '\ufeff';
    const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const prefix = lastConversionType === 'latlong-to-Merchich' ? 'Merchich' : 'latlong';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${prefix}-converted-${timestamp}.csv`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  const citySearchInputElement = document.getElementById('citySearchInput');
  if(citySearchInputElement) {
    citySearchInputElement.addEventListener('beforeinput', handleCitySearchBeforeInput);
    citySearchInputElement.addEventListener('input', handleCitySearchInput);
    citySearchInputElement.addEventListener('focus', handleCitySearchFocus);
    citySearchInputElement.addEventListener('keydown', handleCitySearchKeyDown);
    citySearchInputElement.addEventListener('blur', handleCitySearchBlur);
  }
  const citySearchClearButton = document.getElementById('citySearchClearBtn');
  if(citySearchClearButton) {
    citySearchClearButton.addEventListener('click', handleCitySearchClear);
  }
  const citySuggestionsListElement = document.getElementById('citySuggestionsList');
  if(citySuggestionsListElement) {
    citySuggestionsListElement.addEventListener('click', handleCitySuggestionClick);
  }
  document.addEventListener('click', handleOutsideCitySuggestionClick);
  const conversionTypeElement = document.getElementById('conversionType');
  if(conversionTypeElement) {
    conversionTypeElement.addEventListener('change', () => {
      updateFileHint();
      validateAllCoordinateGroups();
    });
  }
  const csvInputElement = document.getElementById('csvFile');
  if(csvInputElement) {
    csvInputElement.addEventListener('change', handleCsvFileChange);
  }
  window.addEventListener('beforeunload', stopGeoWatch);
  initDmsValidationListeners();
  initManualNumericFields();
  initMap();
  initCityPicker();
  updateFileHint();
  updateConvertButtonState();
  validateAllCoordinateGroups();
  setSingleResultCopyAvailability();
  syncCityClearButtonVisibility();
  setManualPointSelectionState(false);
</script>

</body>
</html>
