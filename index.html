<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>محول إحداثيات X/Y و Lat/Long</title>
<link rel="icon" href="convertgps.png" type="image/x-jpg">
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>

</style>
</head>
<body dir="rtl">

<div class="container">
  <h3 class="my-3">محول إحداثيات X/Y و Lat/Long (D°M'S'')</h3>

  <div class="conversion-header"> 
      <label class="my-2 conversion-label" for="conversionType">اختر المدينة (اجباري)</label>
      <div class=" mb-3 city-select-block">
        <div class="city-search-wrapper">
          <input id="citySearchInput" class="form-control city-search-input bg-success bg-opacity-25" type="search" placeholder="ابحث عن المدينة" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" inputmode="search" aria-label="ابحث عن المدينة" aria-expanded="false" disabled>
          <div id="citySuggestionsList" class="city-suggestions" role="listbox" aria-label="قائمة المدن" hidden></div>
        </div>
      </div>
      <label class="my-2 conversion-label" for="conversionType">اختر نوع التحويل:</label>
      <div>
        <select id="conversionType" class="form-select form-select-sm mb-3 bg-success bg-opacity-25 rounded" aria-label="اختر نوع التحويل">
          <option value="Merchich-to-latlong">X/Y  <span style='font-size:100px; font-weight: bolder;'>&#8680;</span> Lat/Long (D°M'S'')</option>
          <option value="latlong-to-Merchich">Lat/Long (D°M'S'') <span style='font-size:100px; font-weight: bolder;'>&#8680;</span> X/Y</option>
        </select>
      </div>
  </div>
  <div class="live-layout">
    <div class="manual-box">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <h3 class="manual-title">تحويل قيمة واحدة</h3>
        <button type="button" class="reload-btn" onclick="handleReload()" aria-label="إعادة تحميل الصفحة">
          <span aria-hidden="true">⟳</span>
        </button>        
      </div>
      
      <p class="hint" id="manualHint"></p>
      <div class="manual-fields" id="dmsFields">
        <div class="dms-group">
          <label>خط العرض (شمال S/N جنوب):</label>
          <div class="dms-row">
            <input type="text" id="latDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="latSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="latHemisphere" class="hemisphere-select">
              <option value="N"> (N)</option>
              <option value="S"> (S)</option>
            </select>
          </div>
        </div>
        <div class="dms-group">
          <label>خط الطول (شرق W/E غرب):</label>
          <div class="dms-row">
            <input type="text" id="lonDeg" placeholder="درجة °" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonMin" placeholder="دقيقة ′" inputmode="numeric" maxlength="2" oninput="enforceTwoDigits(this)">
            <input type="text" id="lonSec" placeholder="ثانية ″" inputmode="decimal" oninput="sanitizeSeconds(this)" onblur="finalizeSeconds(this)">
            <select id="lonHemisphere" class="hemisphere-select">
              <option value="E"> (E)</option>
              <option value="W" selected> (W)</option>
            </select>
          </div>
        </div>
      </div>
      <div class="manual-fields" id="cartesianFields">
        <input type="text" id="manualX" placeholder="X" inputmode="decimal">
        <input type="text" id="manualY" placeholder="Y" inputmode="decimal">
      </div>
      <button class="manual-btn" onclick="convertSingle()">تحويل الإحداثيات المدخلة</button>
      <div class="result single-result" id="singleResult"></div>
      <button type="button" id="copySingleResultBtn" class="copy-btn" onclick="copySingleResult()" disabled>نسخ النتيجة</button>
    </div>

    <div class="map-box">
      <h3>عرض النقطة على الخريطة</h3>
      <p class="hint">سيتم تحريك العلامة تلقائيًا إلى آخر نقطة تم تحويلها.</p>
      <div class="map-wrapper">
        <button type="button" class="gps-btn" onclick="locateUser()" aria-label="إظهار موقعي الحالي"><i class="bi bi-geo-alt-fill"></i> </button>
        <button type="button" class="basemap-btn" id="basemapToggle" onclick="toggleBasemap()" aria-pressed="false">التبديل بين الخرائط</button>
        <div id="map"></div>
      </div>
    </div>
  </div>

  <div id="batchSection">
    <h3>تحويل عدة قيم </h3>
    <label>اختر ملف CSV للإحداثيات (أعمدة X و Y):</label>
    <input type="file" id="csvFile" accept=".csv">
    <p class="hint" id="fileHint"></p>
    <img src="modelcsvxy.JPG" alt="نموذج ملف CSV" id="csvModelImage" class="csv-image">

    <button id="convertBtn" class="btntout" onclick="convertCSV()" disabled>تحويل جميع الإحداثيات</button>

    <p class="hint" id="layoutHint">بعد التحويل، ضع قيمة Latitude في العمود A وقيمة Longitude في العمود B داخل ملف Excel قبل أي معالجة إضافية.</p>

    <div class="result" id="result"></div>
    <button id="downloadBtn" class="download-btn" onclick="downloadConvertedFile()" disabled>تحميل الملف المحوّل</button>
  </div>
</div>

<script>
  const wgs84 = proj4.WGS84;
  const merchichZones = {
    Zone_I: {
    label: 'Zone I (Nord Maroc)',
    proj: '+proj=lcc +lat_1=33.3 +lat_0=33.3 +lon_0=-5.4 +k_0=0.999625769 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_II: {
      label: 'Zone II (Agadir)',
      proj: '+proj=lcc +lat_1=29.7 +lat_0=29.7 +lon_0=-5.4 +k_0=0.999615596 +x_0=500000 +y_0=300000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_III: {
      label: 'Zone III (La\'youn)',
      proj: '+proj=lcc +lat_1=26.1 +lat_0=26.1 +lon_0=-5.4 +k_0=0.999615596 +x_0=1200000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    },
    Zone_IV: {
      label: 'Zone IV (Ad-Dakhla)',
      proj: '+proj=lcc +lat_1=22.5 +lat_0=22.5 +lon_0=-5.4 +k_0=0.999615596 +x_0=1500000 +y_0=400000 +ellps=clrk80ign +towgs84=31,146,47,0,0,0,0 +units=m +no_defs'
    }
  };

  const zoneValidationLimits = {
    Zone_I: {
      latRange: { min: 31.7278666667, max: 34.8717277778 },
      lonRange: { min: -9.8000, max: -1.8000 },
      planarX: { min: 200000, max: 900000 },
      planarY: { min: 150000, max: 650000 }
    },
    Zone_II: {
      latRange: { min: 28.1063305556, max: 31.2932777778 },
      lonRange: { min: -10.9000, max: -5.4000 },
      planarX: { min: 180000, max: 850000 },
      planarY: { min: 120000, max: 620000 }
    },
    Zone_III: {
      latRange: { min: 24.5075333333, max: 27.6921083333 },
      lonRange: { min: -13.2000, max: -6.8000 },
      planarX: { min: 900000, max: 1600000 },
      planarY: { min: 150000, max: 700000 }
    },
    Zone_IV: {
      latRange: { min: 20.9075750000, max: 24.0921055556 },
      lonRange: { min: -15.5000, max: -8.8000 },
      planarX: { min: 1200000, max: 1900000 },
      planarY: { min: 200000, max: 800000 }
    }
  };
  const defaultZoneKey = 'Zone_I';
  let currentZoneKey = defaultZoneKey;
  let lastConvertedRows = [];
  let lastConvertedFields = null;
  let lastConversionType = null;
  const defaultMapCenter = [33.9, -5.3];
  const basemapConfigs = [
    {
      key: 'osmfr',
      label: 'plan de la ville',
      url: 'https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
      options: {
        attribution: '&copy; OpenStreetMap France & contributors',
        maxZoom: 19
      }
    },
    {
      key: 'imagery',
      label: 'satellite',
      url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      options: {
        attribution: 'Tiles &copy; Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        maxZoom: 19
      }
    }
  ];
  const MAX_FILE_SIZE_BYTES = 1024 * 1024;
  const MAX_CSV_ROWS = 200;
  let mapInstance = null;
  let mapTileLayer = null;
  let currentBasemapIndex = 0;
  let conversionMarker = null;
  let userMarker = null;
  let userAccuracyCircle = null;
  let geoWatchId = null;
  let geoWatchTimeoutId = null;
  let coarseLocationWarned = false;
  let cityOptionsCache = [];
  let selectedCityName = '';
  const CITY_SUGGESTION_LIMIT = 20;
  const CITY_ALLOWED_CHAR_REGEX = /^[A-Za-z ]$/;
  const CITY_ALLOWED_TEXT_REGEX = /^[A-Za-z ]+$/;
  const LAT_INPUT_IDS = ['latDeg', 'latMin', 'latSec'];
  const LON_INPUT_IDS = ['lonDeg', 'lonMin', 'lonSec'];
  const CARTESIAN_INPUT_IDS = ['manualX', 'manualY'];
  const GEO_COORD_INPUT_IDS = [...LAT_INPUT_IDS, ...LON_INPUT_IDS];
  const ZONE_RANGE_ERROR_TEXT = 'Values are out of the allowed zone range.';
  let citySuggestionsHideTimeoutId = null;

  function initMap() {
    const mapElement = document.getElementById('map');
    if(!mapElement || typeof L === 'undefined') {
      return;
    }
    mapInstance = L.map(mapElement, {
      zoomControl: false,
      scrollWheelZoom: false
    }).setView(defaultMapCenter, 6);

    L.control.zoom({ position: 'bottomright' }).addTo(mapInstance);

    L.control.scale({ position: 'bottomleft', metric: true, imperial: false }).addTo(mapInstance);

    applyBasemapLayer(currentBasemapIndex);

  }

  function applyBasemapLayer(index) {
    if(!mapInstance || !basemapConfigs.length) {
      return;
    }
    const normalizedIndex = ((index % basemapConfigs.length) + basemapConfigs.length) % basemapConfigs.length;
    const config = basemapConfigs[normalizedIndex];
    if(!config) {
      return;
    }
    if(mapTileLayer) {
      mapInstance.removeLayer(mapTileLayer);
    }
    mapTileLayer = L.tileLayer(config.url, config.options).addTo(mapInstance);
    currentBasemapIndex = normalizedIndex;
    updateBasemapToggleLabel();
  }

  function toggleBasemap() {
    if(!mapInstance) {
      return;
    }
    const nextIndex = (currentBasemapIndex + 1) % basemapConfigs.length;
    applyBasemapLayer(nextIndex);
  }

  function updateBasemapToggleLabel() {
    const toggleBtn = document.getElementById('basemapToggle');
    if(!toggleBtn) {
      return;
    }
    const current = basemapConfigs[currentBasemapIndex];
    const next = basemapConfigs[(currentBasemapIndex + 1) % basemapConfigs.length];
    toggleBtn.textContent = ` ( الانتقال إلى ${next.label})`;
    toggleBtn.setAttribute('aria-label', `التبديل من ${current.label} إلى ${next.label}`);
    toggleBtn.setAttribute('aria-pressed', current.key === 'imagery' ? 'true' : 'false');
  }

  function updateConversionMarker(latitude, longitude, labelText, zoomLevel = 14) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!conversionMarker) {
      conversionMarker = L.circleMarker(target, {
        radius: 10,
        color: '#d61f46',
        fillColor: '#d61f46',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      conversionMarker.setLatLng(target);
    }
    if(labelText) {
      conversionMarker.bindPopup(labelText).openPopup();
    }
    mapInstance.setView(target, zoomLevel);
  }

  function updateUserLocationMarker(latitude, longitude, labelText, zoomLevel = 16) {
    if(!mapInstance || isNaN(latitude) || isNaN(longitude)) {
      return;
    }
    const target = [latitude, longitude];
    if(!userMarker) {
      userMarker = L.circleMarker(target, {
        radius: 10,
        color: '#1fa86d',
        fillColor: '#1fa86d',
        fillOpacity: 0.9,
        weight: 2
      }).addTo(mapInstance);
    } else {
      userMarker.setLatLng(target);
    }
    if(labelText) {
      userMarker.bindPopup(labelText).openPopup();
    }
    mapInstance.setView(target, zoomLevel);
  }

  function locateUser() {
    if(!mapInstance) {
      alert('الخريطة غير جاهزة بعد. الرجاء الانتظار قليلًا ثم المحاولة مجددًا.');
      return;
    }
    if(!navigator.geolocation) {
      alert('GPS غير مدعوم في هذا المتصفح');
      return;
    }

    stopGeoWatch();
    coarseLocationWarned = false;
    const geoOptions = {
      enableHighAccuracy: true,
      timeout: 15000,
      maximumAge: 0
    };

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy === null || accuracy > 120) {
          startGeoWatch(geoOptions);
        }
      },
      (error) => {
        handleUserLocationError(error);
      },
      geoOptions
    );
  }

  function handleUserLocationSuccess(position) {
    const latitude = position.coords.latitude;
    const longitude = position.coords.longitude;
    const accuracy = Number.isFinite(position.coords.accuracy) ? Math.round(position.coords.accuracy) : null;
    const latDmsText = formatDMS(decimalToDMS(latitude, true));
    const lonDmsText = formatDMS(decimalToDMS(longitude, false));
    const popupHeader = accuracy !== null
      ? `Ma position actuelle (±${accuracy} m)`
      : 'Ma position actuelle';
    const popupText = `${popupHeader}<br>${wrapDmsHtml(latDmsText, lonDmsText)}`;

    updateUserLocationMarker(latitude, longitude, popupText, 16);

    const circleTarget = [latitude, longitude];
    if(accuracy !== null) {
      if(!userAccuracyCircle) {
        userAccuracyCircle = L.circle(circleTarget, {
          radius: accuracy,
          color: '#1fa86d',
          fillColor: '#1fa86d',
          fillOpacity: 0.15,
          weight: 1
        }).addTo(mapInstance);
      } else {
        userAccuracyCircle.setLatLng(circleTarget);
        userAccuracyCircle.setRadius(accuracy);
      }
    } else if(userAccuracyCircle) {
      mapInstance.removeLayer(userAccuracyCircle);
      userAccuracyCircle = null;
    }

    if(accuracy !== null && accuracy > 10000 && !coarseLocationWarned) {
      alert('تم الحصول على موقع تقريبي فقط. الرجاء تفعيل GPS أو الاتصال بشبكة Wi-Fi للحصول على دقة أعلى.');
      coarseLocationWarned = true;
    }

    return accuracy;
  }

  function handleUserLocationError(error) {
    stopGeoWatch();
    if(error && error.code === error.PERMISSION_DENIED) {
      alert('تم رفض إذن الموقع');
      return;
    }
    if(error && error.code === error.POSITION_UNAVAILABLE) {
      alert('تعذر تحديد موقعك. تأكد من تفعيل GPS أو خدمات الموقع ثم أعد المحاولة.');
      return;
    }
    if(error && error.code === error.TIMEOUT) {
      alert('انتهت مهلة الحصول على الموقع. حاول مرة أخرى بعد التأكد من تفعيل GPS.');
      return;
    }
    alert('تعذر الحصول على الموقع الحالي');
  }

  function startGeoWatch(options) {
    if(typeof navigator.geolocation.watchPosition !== 'function') {
      return;
    }
    stopGeoWatch();
    geoWatchId = navigator.geolocation.watchPosition(
      (position) => {
        const accuracy = handleUserLocationSuccess(position);
        if(accuracy !== null && accuracy <= 60) {
          stopGeoWatch();
        }
      },
      (error) => {
        stopGeoWatch();
        handleUserLocationError(error);
      },
      options
    );

    geoWatchTimeoutId = window.setTimeout(() => {
      stopGeoWatch();
    }, 20000);
  }

  function stopGeoWatch() {
    if(geoWatchId !== null) {
      navigator.geolocation.clearWatch(geoWatchId);
      geoWatchId = null;
    }
    if(geoWatchTimeoutId) {
      clearTimeout(geoWatchTimeoutId);
      geoWatchTimeoutId = null;
    }
  }

  function updateFileHint() {
    const type = document.getElementById('conversionType').value;
    const hint = document.getElementById('fileHint');
    const manualHint = document.getElementById('manualHint');
    const csvImage = document.getElementById('csvModelImage');
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const batchSection = document.getElementById('batchSection');
    toggleManualFields(type);

    if(type === "latlong-to-Merchich") {
      const disabledMsg = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S''). الرجاء استخدام التحويل اليدوي لهذا الاتجاه.";
      if(hint) {
        hint.dataset.defaultMessage = disabledMsg;
        hint.innerText = disabledMsg;
      }
      manualHint.innerText = "أدخل خطوط الطول والعرض (D°M'S'') ليتم تحويلها إلى إحداثيات X و Y باستخدام المنطقة المرتبطة بالمدينة المختارة.";
      if(batchSection) batchSection.style.display = 'none';
      if(csvImage) {
        csvImage.style.display = 'none';
      }
      if(fileInput) {
        fileInput.value = '';
        fileInput.disabled = true;
      }
      if(convertBtn) convertBtn.disabled = true;
      if(downloadBtn) downloadBtn.disabled = true;
      lastConvertedRows = [];
      lastConvertedFields = null;
    } else {
      const activeMsg = "ارفع ملف CSV (أعمدة X و Y) بحجم لا يتجاوز 1 ميغابايت وبعدد أسطر لا يتخطى 200 ليتم تحويله إلى Lat/Long (D°M'S'') وفق المنطقة الخاصة بالمدينة المختارة أو المنطقة الافتراضية.";
      if(hint) {
        hint.dataset.defaultMessage = activeMsg;
        hint.innerText = activeMsg;
      }
      manualHint.innerText = " اختر المدينة ثم أدخل إحداثيات (X, Y) يدويًا ليتم تحويلها مباشرة إلى Lat/Long باستخدام المنطقة المناسبة.";
      if(batchSection) batchSection.style.display = 'block';
      if(csvImage) {
        csvImage.src = 'modelcsvxy.JPG';
        csvImage.style.display = 'block';
      }
      if(fileInput) fileInput.disabled = false;
      updateConvertButtonState();
    }
  }

  function toggleManualFields(type) {
    const dmsFields = document.getElementById('dmsFields');
    const cartesianFields = document.getElementById('cartesianFields');
    if(type === "latlong-to-Merchich") {
      dmsFields.style.display = 'flex';
      cartesianFields.style.display = 'none';
    } else {
      dmsFields.style.display = 'none';
      cartesianFields.style.display = 'flex';
    }
  }

  function dmsToDecimal(deg, min, sec, hemisphere) {
    if(isNaN(deg) || isNaN(min) || isNaN(sec)) {
      return NaN;
    }
    const absValue = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const hemisphereSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    const degreeSign = deg < 0 ? -1 : 1;
    return absValue * hemisphereSign * degreeSign;
  }

  function decimalToDMS(value, isLatitude) {
    if(isNaN(value)) return null;
    const absValue = Math.abs(value);
    const degrees = Math.floor(absValue);
    const minutesFloat = (absValue - degrees) * 60;
    const minutes = Math.floor(minutesFloat);
    const seconds = (minutesFloat - minutes) * 60;
    const hemisphere = isLatitude
      ? (value < 0 ? 'S' : 'N')
      : (value < 0 ? 'W' : 'E');
    return { degrees, minutes, seconds, hemisphere, isLatitude };
  }

  function padTwoDigits(value) {
    return value < 10 ? `0${value}` : `${value}`;
  }

  function padSeconds(seconds) {
    const str = seconds.toFixed(2);
    return seconds < 10 ? `0${str}` : str;
  }

  function enforceNumericCharacters(input, options = {}) {
    if(!input) {
      return '';
    }
    const {
      allowDecimal = false,
      allowNegative = false,
      maxLength = null,
      decimalSeparatorReplacement = null
    } = options;
    const rawValue = input.value || '';
    let sanitized = '';
    let decimalUsed = false;
    let decimalChar = null;

    for(let index = 0; index < rawValue.length; index++) {
      const char = rawValue[index];
      if(char >= '0' && char <= '9') {
        sanitized += char;
        continue;
      }
      if(allowDecimal && (char === '.' || char === ',')) {
        if(decimalUsed) {
          continue;
        }
        sanitized += char;
        decimalUsed = true;
        decimalChar = char;
        continue;
      }
      if(allowNegative && char === '-' && sanitized.length === 0) {
        sanitized = '-';
      }
    }

    if(!allowNegative) {
      sanitized = sanitized.replace(/-/g, '');
    } else if(sanitized.indexOf('-') > 0) {
      sanitized = sanitized.replace(/-/g, '');
      sanitized = `-${sanitized}`;
    }

    if(typeof maxLength === 'number' && maxLength > 0 && !allowDecimal) {
      const isNegative = allowNegative && sanitized.startsWith('-');
      const limit = maxLength + (isNegative ? 1 : 0);
      sanitized = sanitized.slice(0, limit);
    }

    if(!allowDecimal) {
      sanitized = sanitized.replace(/[.,]/g, '');
    } else if(decimalSeparatorReplacement && decimalChar && decimalChar !== decimalSeparatorReplacement) {
      const decimalIndex = sanitized.indexOf(decimalChar);
      if(decimalIndex !== -1) {
        sanitized = sanitized.slice(0, decimalIndex) + decimalSeparatorReplacement + sanitized.slice(decimalIndex + 1);
      }
    }

    if(input.value !== sanitized) {
      input.value = sanitized;
    }
    return sanitized;
  }

  function enforceTwoDigits(input) {
    enforceNumericCharacters(input, { maxLength: 2 });
  }

  function sanitizeSeconds(input) {
    enforceNumericCharacters(input, { allowDecimal: true });
  }

  function finalizeSeconds(input) {
    let value = input.value.trim();
    if(value === '') return;
    const usesComma = value.includes(',');
    const usesDot = value.includes('.');
    const normalized = value.replace(',', '.');
    let num = parseFloat(normalized);
    if(isNaN(num)) {
      input.value = '';
      return;
    }
    num = Math.min(59.99, Math.max(0, num));
    if(usesComma || usesDot) {
      const truncated = Math.floor(num * 100) / 100;
      let str = truncated.toFixed(2);
      if(usesComma && !usesDot) {
        str = str.replace('.', ',');
      }
      input.value = str;
    } else {
      input.value = Math.round(num).toString();
    }
  }

  function readSecondsValue(elementId) {
    const raw = document.getElementById(elementId).value.trim();
    if(raw === '') return NaN;
    const normalized = raw.replace(',', '.');
    const num = parseFloat(normalized);
    if(isNaN(num)) return NaN;
    const clamped = Math.min(59.99, Math.max(0, num));
    return Math.floor(clamped * 100) / 100;
  }

  function areInputsFilled(inputIds) {
    return inputIds.every((id) => {
      const element = document.getElementById(id);
      return element && element.value.trim() !== '';
    });
  }

  function setInputsValidity(inputIds, { reset = false, isValid = true, message = '' } = {}) {
    inputIds.forEach((id) => {
      const element = document.getElementById(id);
      if(!element) {
        return;
      }
      if(reset) {
        element.classList.remove('is-invalid');
        element.removeAttribute('aria-invalid');
        element.removeAttribute('title');
        return;
      }
      if(isValid) {
        element.classList.remove('is-invalid');
        element.removeAttribute('aria-invalid');
        element.removeAttribute('title');
        return;
      }
      element.classList.add('is-invalid');
      element.setAttribute('aria-invalid', 'true');
      if(message) {
        element.setAttribute('title', message);
      } else {
        element.removeAttribute('title');
      }
    });
  }

  function getActiveValidationLimits() {
    if(zoneValidationLimits[currentZoneKey]) {
      return zoneValidationLimits[currentZoneKey];
    }
    return zoneValidationLimits[defaultZoneKey] || null;
  }

  function getDmsDecimal(prefix) {
    const deg = parseFloat(document.getElementById(`${prefix}Deg`).value);
    const min = parseFloat(document.getElementById(`${prefix}Min`).value);
    const sec = readSecondsValue(`${prefix}Sec`);
    const hemisphereElement = document.getElementById(`${prefix}Hemisphere`);
    const hemisphere = hemisphereElement ? hemisphereElement.value : (prefix === 'lat' ? 'N' : 'E');
    return dmsToDecimal(deg, min, sec, hemisphere);
  }

  function validateGeographicInputs() {
    const conversionType = document.getElementById('conversionType').value;
    const limits = getActiveValidationLimits();
    if(conversionType !== 'latlong-to-Merchich' || !selectedCityName || !limits) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'skipped' };
    }

    if(!areInputsFilled(GEO_COORD_INPUT_IDS)) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'incomplete' };
    }

    const latValue = getDmsDecimal('lat');
    const lonValue = getDmsDecimal('lon');
    if(!Number.isFinite(latValue) || !Number.isFinite(lonValue)) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'invalid-input' };
    }

    const latRange = limits.latRange;
    const lonRange = limits.lonRange;
    if(!latRange || !lonRange) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
      return { status: 'range-missing', latValue, lonValue };
    }

    const latInRange = latValue >= latRange.min && latValue <= latRange.max;
    const lonInRange = lonValue >= lonRange.min && lonValue <= lonRange.max;
    const isValid = latInRange && lonInRange;
    if(!isValid) {
      setInputsValidity(GEO_COORD_INPUT_IDS, { isValid: false, message: ZONE_RANGE_ERROR_TEXT });
    } else {
      setInputsValidity(GEO_COORD_INPUT_IDS, { reset: true });
    }
    return { status: 'validated', isValid, latValue, lonValue };
  }

  function validatePlanarInputs() {
    const conversionType = document.getElementById('conversionType').value;
    const limits = getActiveValidationLimits();
    if(conversionType !== 'Merchich-to-latlong' || !selectedCityName || !limits) {
      setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
      return { status: 'skipped' };
    }

    if(!areInputsFilled(CARTESIAN_INPUT_IDS)) {
      setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
      return { status: 'incomplete' };
    }

    const xValue = parseFloat(document.getElementById('manualX').value);
    const yValue = parseFloat(document.getElementById('manualY').value);
    if(!Number.isFinite(xValue) || !Number.isFinite(yValue)) {
      setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
      return { status: 'invalid-input' };
    }

    const xRange = limits.planarX;
    const yRange = limits.planarY;
    if(!xRange || !yRange) {
      setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
      return { status: 'range-missing', xValue, yValue };
    }

    const inRange = xValue >= xRange.min && xValue <= xRange.max
      && yValue >= yRange.min && yValue <= yRange.max;
    if(!inRange) {
      setInputsValidity(CARTESIAN_INPUT_IDS, { isValid: false, message: ZONE_RANGE_ERROR_TEXT });
    } else {
      setInputsValidity(CARTESIAN_INPUT_IDS, { reset: true });
    }
    return { status: 'validated', isValid: inRange, xValue, yValue };
  }

  function validateAllCoordinateGroups() {
    validateGeographicInputs();
    validatePlanarInputs();
  }

  function formatDMS(dms) {
    if(!dms) return '';
    const degreeWidth = dms.isLatitude ? 2 : 3;
    const degreeStr = dms.degrees.toString().padStart(degreeWidth, '0');
    const minuteStr = padTwoDigits(dms.minutes);
    const secondStr = padSeconds(dms.seconds);
    return `${degreeStr}° ${minuteStr}' ${secondStr}" ${dms.hemisphere}`;
  }

  function wrapDmsHtml(latText, lonText) {
    const safeLat = latText || '';
    const safeLon = lonText || '';
    return `<span class="dms-popup">${safeLat}<br>${safeLon}</span>`;
  }

  function normalizeDmsString(value) {
    return value.toString()
      .replace(/,/g, '.')
      .replace(/″|”|“/g, '"')
      .replace(/′|’|`/g, "'")
      .replace(/º|˚/g, '°')
      .trim();
  }

  function parseCsvDms(value, hemisphere) {
    if(value === undefined || value === null) return NaN;
    const normalized = normalizeDmsString(value);
    const cleaned = normalized
      .replace(/[NSEW]\s*$/i, '')
      .replace(/"/g, '')
      .trim();
    const regex = /(-?\d+(?:\.\d+)?)\s*°\s*(\d+(?:\.\d+)?)\s*['′’]\s*(\d+(?:\.\d+)?)/;
    const match = cleaned.match(regex);
    if(!match) return NaN;
    const deg = parseFloat(match[1]);
    const min = parseFloat(match[2]);
    const sec = parseFloat(match[3]);
    const base = Math.abs(deg) + (Math.abs(min) / 60) + (Math.abs(sec) / 3600);
    const degreeSign = deg < 0 ? -1 : 1;
    const hemiSign = (hemisphere === 'S' || hemisphere === 'W') ? -1 : 1;
    return base * degreeSign * hemiSign;
  }

  function getCsvField(row, targetKey) {
    const normalizedTarget = normalizeKeyName(targetKey);
    for (const key in row) {
      if(!Object.prototype.hasOwnProperty.call(row, key)) continue;
      if(typeof key !== 'string') continue;
      if(normalizeKeyName(key) === normalizedTarget) {
        return row[key];
      }
    }
    return undefined;
  }

  function hasField(fields, targetKey) {
    if(!Array.isArray(fields)) return false;
    const normalizedKey = normalizeKeyName(targetKey);
    return fields.some(field => {
      if(field === undefined || field === null) return false;
      return normalizeKeyName(field) === normalizedKey;
    });
  }

  function normalizeKeyName(key) {
    if(key === undefined || key === null) return '';
    return key.toString().replace(/\ufeff/g, '').trim().toLowerCase();
  }

  function updateConvertButtonState() {
    const fileInput = document.getElementById('csvFile');
    const convertBtn = document.getElementById('convertBtn');
    const type = document.getElementById('conversionType').value;
    if(!convertBtn || !fileInput) return;
    if(type !== 'Merchich-to-latlong') {
      convertBtn.disabled = true;
      return;
    }
    const file = fileInput.files[0];
    const isValidSize = file ? file.size <= MAX_FILE_SIZE_BYTES : false;
    convertBtn.disabled = !isValidSize;
  }

  function handleCsvFileChange() {
    const fileInput = document.getElementById('csvFile');
    const hint = document.getElementById('fileHint');
    if(!fileInput) return;
    const file = fileInput.files[0];
    if(file && file.size > MAX_FILE_SIZE_BYTES) {
      const sizeMb = (file.size / (1024 * 1024)).toFixed(2);
      if(hint) {
        hint.innerText = `حجم الملف ${sizeMb} ميغابايت وهو أكبر من الحد المسموح (1 ميغابايت). اختر ملفًا أصغر ثم أعد المحاولة.`;
      }
      fileInput.value = '';
    } else if(hint && hint.dataset.defaultMessage) {
      hint.innerText = hint.dataset.defaultMessage;
    }

    updateConvertButtonState();
    lastConvertedRows = [];
    lastConvertedFields = null;
    const downloadBtn = document.getElementById('downloadBtn');
    if(downloadBtn) downloadBtn.disabled = true;
  }

  function normalizeZoneKey(zoneValue) {
    if(typeof zoneValue !== 'string') {
      return '';
    }
    return zoneValue
      .trim()
      .replace(/\s+/g, '_')
      .replace(/-+/g, '_')
      .replace(/zone/gi, 'Zone');
  }

  function getZoneDisplayLabel(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    const zoneConfig = merchichZones[normalized];
    if(zoneConfig && zoneConfig.label) {
      return zoneConfig.label;
    }
    return normalized ? normalized.replace(/_/g, ' ') : '';
  }

  function getCurrentZoneConfig() {
    return merchichZones[currentZoneKey] || merchichZones[defaultZoneKey] || null;
  }

  function setActiveZone(zoneKey) {
    const normalized = normalizeZoneKey(zoneKey);
    if(normalized && merchichZones[normalized]) {
      currentZoneKey = normalized;
    } else {
      currentZoneKey = defaultZoneKey;
    }
  }

  function initManualNumericFields() {
    const manualNumericInputs = [
      { id: 'manualX', options: { allowDecimal: true, decimalSeparatorReplacement: '.' } },
      { id: 'manualY', options: { allowDecimal: true, decimalSeparatorReplacement: '.' } }
    ];

    manualNumericInputs.forEach(({ id, options }) => {
      const element = document.getElementById(id);
      if(!element) {
        return;
      }
      const handler = () => {
        enforceNumericCharacters(element, options);
        validatePlanarInputs();
      };
      element.addEventListener('input', handler);
      element.addEventListener('blur', handler);
    });
  }

  function initDmsValidationListeners() {
    const registerGroup = (ids, callback) => {
      ids.forEach((id) => {
        const element = document.getElementById(id);
        if(!element) {
          return;
        }
        element.addEventListener('input', callback);
        element.addEventListener('blur', callback);
      });
    };
    registerGroup(LAT_INPUT_IDS, () => validateGeographicInputs());
    registerGroup(LON_INPUT_IDS, () => validateGeographicInputs());
    const latHem = document.getElementById('latHemisphere');
    if(latHem) {
      latHem.addEventListener('change', () => validateGeographicInputs());
    }
    const lonHem = document.getElementById('lonHemisphere');
    if(lonHem) {
      lonHem.addEventListener('change', () => validateGeographicInputs());
    }
  }


  function flattenCityZones(cityData) {
    const flattened = {};
    if(!cityData || typeof cityData !== 'object') {
      return flattened;
    }
    Object.entries(cityData).forEach(([key, value]) => {
      if(Array.isArray(value)) {
        const zoneKey = normalizeZoneKey(key);
        if(!zoneKey) {
          return;
        }
        value.forEach((cityName) => {
          if(typeof cityName !== 'string') {
            return;
          }
          const trimmed = cityName.trim();
          if(!trimmed) {
            return;
          }
          flattened[trimmed] = zoneKey;
        });
        return;
      }
      if(typeof value === 'string') {
        const zoneKey = normalizeZoneKey(value);
        if(!zoneKey) {
          return;
        }
        const trimmedKey = typeof key === 'string' ? key.trim() : key;
        if(!trimmedKey) {
          return;
        }
        flattened[trimmedKey] = zoneKey;
      }
    });
    return flattened;
  }

  function getCityDisplayLabel(name) {
    if(!name) {
      return '';
    }
    const match = cityOptionsCache.find((entry) => entry.name === name);
    return match ? match.display : '';
  }

  function getCityEntryByName(name) {
    if(!name) {
      return null;
    }
    return cityOptionsCache.find((entry) => entry.name === name) || null;
  }

  function clearSelectedCityState() {
    selectedCityName = '';
    setActiveZone('');
    updateCityZoneBadge('');
    validateAllCoordinateGroups();
  }

  function commitCitySelection(entry) {
    if(!entry) {
      clearSelectedCityState();
      hideCitySuggestionsList();
      return;
    }
    selectedCityName = entry.name;
    const normalizedZone = normalizeZoneKey(entry.zoneKey);
    const zoneLabel = normalizedZone ? getZoneDisplayLabel(normalizedZone) : '';
    setActiveZone(normalizedZone);
    updateCityZoneBadge(zoneLabel);
    const searchInput = document.getElementById('citySearchInput');
    if(searchInput) {
      const displayValue = entry.display || entry.name;
      searchInput.value = displayValue;
      if(typeof searchInput.setSelectionRange === 'function') {
        const cursorPos = displayValue.length;
        searchInput.setSelectionRange(cursorPos, cursorPos);
      }
    }
    hideCitySuggestionsList();
    validateAllCoordinateGroups();
  }

  function updateCitySearchInputUI({ disabled = false, placeholderText } = {}) {
    const searchInput = document.getElementById('citySearchInput');
    if(!searchInput) {
      return;
    }
    const placeholder = placeholderText || (disabled ? 'قائمة المدن غير متاحة' : 'ابحث عن المدينة');
    searchInput.placeholder = placeholder;
    if(disabled) {
      searchInput.value = '';
      searchInput.setAttribute('disabled', 'true');
      return;
    }
    searchInput.removeAttribute('disabled');
    if(selectedCityName && !searchInput.matches(':focus')) {
      const label = getCityDisplayLabel(selectedCityName) || selectedCityName;
      searchInput.value = label;
    }
  }

  // Restrict city search input to alphabetic characters and spaces
  function sanitizeCitySearchValueWithCaret(value, caretPosition) {
    if(typeof value !== 'string') {
      return { sanitizedValue: '', nextCaret: 0 };
    }
    let sanitizedValue = '';
    let nextCaret = typeof caretPosition === 'number' ? caretPosition : value.length;
    for(let index = 0; index < value.length; index++) {
      const char = value[index];
      if(CITY_ALLOWED_CHAR_REGEX.test(char)) {
        sanitizedValue += char;
      } else if(index < nextCaret) {
        nextCaret--;
      }
    }
    nextCaret = Math.max(0, Math.min(nextCaret, sanitizedValue.length));
    return { sanitizedValue, nextCaret };
  }

  function enforceCitySearchAlphaOnly(inputElement) {
    if(!inputElement) {
      return '';
    }
    const rawValue = inputElement.value || '';
    const caretPosition = typeof inputElement.selectionStart === 'number'
      ? inputElement.selectionStart
      : rawValue.length;
    const { sanitizedValue, nextCaret } = sanitizeCitySearchValueWithCaret(rawValue, caretPosition);
    if(rawValue !== sanitizedValue) {
      inputElement.value = sanitizedValue;
      if(typeof inputElement.setSelectionRange === 'function') {
        inputElement.setSelectionRange(nextCaret, nextCaret);
      }
    }
    return inputElement.value;
  }

  function handleCitySearchBeforeInput(event) {
    if(!event || typeof event.data !== 'string') {
      return;
    }
    if(event.data && !CITY_ALLOWED_TEXT_REGEX.test(event.data)) {
      event.preventDefault();
    }
  }

  function renderCitySuggestions(filterText = '', forceOpen = false) {
    if(!cityOptionsCache.length) {
      hideCitySuggestionsList();
      return;
    }
    const normalized = filterText.trim().toLowerCase();
    const matches = cityOptionsCache.filter((entry) => {
      if(!normalized) {
        return true;
      }
      return entry.name.toLowerCase().startsWith(normalized) || entry.display.toLowerCase().startsWith(normalized);
    }).slice(0, CITY_SUGGESTION_LIMIT);
    const shouldOpen = forceOpen || isCitySearchInputFocused();
    updateCitySuggestionList(matches, normalized, shouldOpen);
  }

  function isCitySearchInputFocused() {
    const input = document.getElementById('citySearchInput');
    return Boolean(input && document.activeElement === input);
  }

  function updateCitySuggestionList(matches, normalizedFilter, shouldOpen) {
    const listElement = document.getElementById('citySuggestionsList');
    if(!listElement) {
      syncCitySearchExpandedState(false);
      return;
    }
    listElement.innerHTML = '';
    if(!shouldOpen) {
      listElement.hidden = true;
      syncCitySearchExpandedState(false);
      return;
    }
    if(!matches.length) {
      if(normalizedFilter) {
        const emptyState = document.createElement('div');
        emptyState.className = 'city-suggestion-empty';
        emptyState.textContent = 'لا توجد مدينة مطابقة';
        listElement.appendChild(emptyState);
        listElement.hidden = false;
        syncCitySearchExpandedState(true);
      } else {
        listElement.hidden = true;
        syncCitySearchExpandedState(false);
      }
      return;
    }
    const fragment = document.createDocumentFragment();
    matches.forEach((entry) => {
      const optionButton = document.createElement('button');
      optionButton.type = 'button';
      optionButton.className = 'city-suggestion-item';
      optionButton.dataset.cityName = entry.name;
      optionButton.dataset.display = entry.display;
      optionButton.textContent = entry.display;
      optionButton.setAttribute('role', 'option');
      fragment.appendChild(optionButton);
    });
    listElement.appendChild(fragment);
    listElement.hidden = false;
    syncCitySearchExpandedState(true);
  }

  function hideCitySuggestionsList() {
    cancelCitySuggestionsHide();
    const listElement = document.getElementById('citySuggestionsList');
    if(listElement) {
      listElement.hidden = true;
      listElement.innerHTML = '';
    }
    syncCitySearchExpandedState(false);
  }

  function syncCitySearchExpandedState(isOpen) {
    const input = document.getElementById('citySearchInput');
    if(input) {
      input.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }
  }

  function findCityMatchByInput(inputValue) {
    const normalized = inputValue ? inputValue.trim().toLowerCase() : '';
    if(!normalized) {
      return null;
    }
    return cityOptionsCache.find((entry) => entry.display.toLowerCase() === normalized || entry.name.toLowerCase() === normalized)
      || cityOptionsCache.find((entry) => entry.display.toLowerCase().startsWith(normalized) || entry.name.toLowerCase().startsWith(normalized))
      || null;
  }

  function applyCitySelectionFromName(name) {
    commitCitySelection(getCityEntryByName(name));
  }

  function handleCitySearchInput(event) {
    if(!event || !event.target) {
      return;
    }
    const value = enforceCitySearchAlphaOnly(event.target);
    cancelCitySuggestionsHide();
    renderCitySuggestions(value, true);
    const match = findCityMatchByInput(value);
    const normalized = value.trim().toLowerCase();
    if(match && (match.display.toLowerCase() === normalized || match.name.toLowerCase() === normalized)) {
      applyCitySelectionFromName(match.name);
    } else {
      clearSelectedCityState();
    }
  }

  function handleCitySearchFocus() {
    cancelCitySuggestionsHide();
    const input = document.getElementById('citySearchInput');
    const value = input ? input.value : '';
    renderCitySuggestions(value, true);
  }

  function handleCitySearchKeyDown(event) {
    if(event.key === 'Escape') {
      hideCitySuggestionsList();
      return;
    }
    if(event.key === 'Enter') {
      const match = findCityMatchByInput(event.target.value || '');
      if(match) {
        event.preventDefault();
        applyCitySelectionFromName(match.name);
      }
    }
  }

  function cancelCitySuggestionsHide() {
    if(citySuggestionsHideTimeoutId) {
      clearTimeout(citySuggestionsHideTimeoutId);
      citySuggestionsHideTimeoutId = null;
    }
  }

  function handleCitySearchBlur() {
    cancelCitySuggestionsHide();
    citySuggestionsHideTimeoutId = window.setTimeout(() => {
      const listElement = document.getElementById('citySuggestionsList');
      const searchInput = document.getElementById('citySearchInput');
      const activeElement = document.activeElement;
      if(activeElement && (activeElement === searchInput || (listElement && listElement.contains(activeElement)))) {
        return;
      }
      hideCitySuggestionsList();
    }, 120);
  }

  function handleCitySuggestionClick(event) {
    const target = event.target.closest('.city-suggestion-item');
    if(!target) {
      return;
    }
    const cityName = target.dataset.cityName;
    if(!cityName) {
      return;
    }
    applyCitySelectionFromName(cityName);
  }

  function handleOutsideCitySuggestionClick(event) {
    if(event.target.closest('.city-search-wrapper')) {
      return;
    }
    hideCitySuggestionsList();
  }

  function initCityPicker() {
    if(typeof fetch !== 'function') {
      return;
    }
    fetch('ville.json', { cache: 'no-store' })
      .then((response) => {
        if(!response.ok) {
          throw new Error('Failed to load cities');
        }
        return response.json();
      })
      .then(populateCityOptions)
      .catch(handleCityLoadError);
  }

  function populateCityOptions(cityData) {
    const flattened = flattenCityZones(cityData);
    const entries = Object.entries(flattened);
    if(!entries.length) {
      cityOptionsCache = [];
      clearSelectedCityState();
      updateCitySearchInputUI({ disabled: true, placeholderText: 'لا توجد مدن متاحة' });
      hideCitySuggestionsList();
      return;
    }
    cityOptionsCache = entries.map(([name, zoneKey]) => {
      const zoneLabel = getZoneDisplayLabel(zoneKey);
      return {
        name,
        zoneKey,
        display: zoneLabel ? `${name} — ${zoneLabel}` : name
      };
    }).sort((a, b) => a.name.localeCompare(b.name, 'ar', { sensitivity: 'base', numeric: true }));

    if(selectedCityName && !getCityEntryByName(selectedCityName)) {
      clearSelectedCityState();
    }

    updateCitySearchInputUI({ disabled: false });
    renderCitySuggestions('', false);
  }

  function handleCityLoadError() {
    cityOptionsCache = [];
    clearSelectedCityState();
    updateCitySearchInputUI({ disabled: true, placeholderText: 'تعذر تحميل المدن' });
    hideCitySuggestionsList();
  }

  function updateCityZoneBadge(zoneText) {
    const badge = document.getElementById('cityZoneBadge');
    if(!badge) return;
    if(!zoneText) {
      badge.textContent = '';
      badge.hidden = true;
      return;
    }
    badge.textContent = zoneText;
    badge.hidden = false;
  }


  function handleReload() {
    window.location.reload();
  }

  function setSingleResultCopyAvailability() {
    const resultDiv = document.getElementById('singleResult');
    const copyBtn = document.getElementById('copySingleResultBtn');
    if(!copyBtn || !resultDiv) {
      return;
    }
    copyBtn.disabled = resultDiv.innerText.trim().length === 0;
  }

  function fallbackCopyToClipboard(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'absolute';
    textarea.style.left = '-9999px';
    document.body.appendChild(textarea);
    textarea.select();
    let copied = false;
    try {
      copied = document.execCommand('copy');
    } catch (error) {
      copied = false;
    }
    document.body.removeChild(textarea);
    if(!copied) {
      alert('تعذر نسخ النتيجة تلقائيًا. الرجاء النسخ يدويًا.');
    }
  }

  function copySingleResult() {
    const resultDiv = document.getElementById('singleResult');
    if(!resultDiv) {
      return;
    }
    const text = resultDiv.innerText.trim();
    if(!text) {
      return;
    }
    if(navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
      navigator.clipboard.writeText(text).catch(() => fallbackCopyToClipboard(text));
    } else {
      fallbackCopyToClipboard(text);
    }
  }

  function convertCSV() {
    const file = document.getElementById('csvFile').files[0];
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('result');
    const downloadBtn = document.getElementById('downloadBtn');
    const searchInput = document.getElementById('citySearchInput');
    const zoneConfig = getCurrentZoneConfig();

    if(!selectedCityName) {
      resultDiv.innerText = 'الرجاء اختيار مدينة عبر مربع البحث قبل تحويل ملفات CSV.';
      if(searchInput) {
        searchInput.focus();
      }
      return;
    }

    if(!zoneConfig) {
      resultDiv.innerText = 'لا يوجد نظام إسقاط صالح لهذا التحويل. الرجاء اختيار مدينة مرتبطة بمنطقة معتمدة.';
      return;
    }

    const zoneLabel = getZoneDisplayLabel(currentZoneKey) || 'Zone I';

    lastConvertedRows = [];
    lastConvertedFields = null;
    lastConversionType = null;
    if(downloadBtn) downloadBtn.disabled = true;

    if(type !== "Merchich-to-latlong") {
      resultDiv.innerText = "تحويل الملفات متاح فقط لاتجاه X/Y → Lat/Long (D°M'S'').";
      return;
    }

    if (!file) {
      resultDiv.innerHTML = "Veuillez d'abord sélectionner un fichier CSV.";
      return;
    }

    if(file.size > MAX_FILE_SIZE_BYTES) {
      resultDiv.innerText = 'حجم الملف يتجاوز 1 ميغابايت المسموح بها. الرجاء اختيار ملف أصغر ثم إعادة المحاولة.';
      return;
    }

    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: 'greedy',
      complete: function(results) {
        const data = results.data || [];
        if(data.length > MAX_CSV_ROWS) {
          resultDiv.innerText = `عدد الأسطر ${data.length} ويتجاوز الحد المسموح به (${MAX_CSV_ROWS})، الرجاء تقليص الملف ثم إعادة المحاولة.`;
          return;
        }
        const fields = (results.meta && Array.isArray(results.meta.fields)) ? results.meta.fields : [];
        if(!hasField(fields, 'X') || !hasField(fields, 'Y')) {
          const existing = fields.length ? fields.join(', ') : 'بدون رؤوس واضحة';
          resultDiv.innerText = `لم يتم العثور على عمودين باسم X و Y. الأعمدة الحالية في الملف: ${existing}`;
          return;
        }
        let output = `الإحداثيات المحوّلة (عمود A = Latitude، عمود B = Longitude) — ${zoneLabel}:\n\n`;
        const convertedRows = [];

        data.forEach((row, index) => {
          const xVal = getCsvField(row, 'X');
          const yVal = getCsvField(row, 'Y');
          if(xVal === undefined || yVal === undefined) return;
          const x = parseFloat(xVal);
          const y = parseFloat(yVal);
          if(isNaN(x) || isNaN(y)) return;

          const [lon, lat] = proj4(zoneConfig.proj, wgs84, [x, y]);
          const latDms = decimalToDMS(lat, true);
          const lonDms = decimalToDMS(lon, false);
          output += `Ligne ${index+1} : Latitude ${formatDMS(latDms)}, Longitude ${formatDMS(lonDms)}\n`;
          convertedRows.push({ Latitude: formatDMS(latDms), Longitude: formatDMS(lonDms) });
        });

        if(!convertedRows.length) {
          const attempted = data.length;
          resultDiv.innerText = `لم يتم العثور على صفوف صالحة للتحويل بعد فحص ${attempted} صفًا. تأكد من أن كل صف يحتوي على قيم رقمية في عمودي X و Y.`;
          return;
        }

        resultDiv.innerText = output;
        lastConvertedRows = convertedRows;
        lastConvertedFields = ['Latitude', 'Longitude'];
        lastConversionType = type;
        if(downloadBtn) downloadBtn.disabled = false;
      }
    });
  }

  function convertSingle() {
    const type = document.getElementById('conversionType').value;
    const resultDiv = document.getElementById('singleResult');
    const searchInput = document.getElementById('citySearchInput');
    if(!selectedCityName) {
      resultDiv.innerText = 'الرجاء اختيار مدينة عبر مربع البحث قبل إجراء التحويل.';
      setSingleResultCopyAvailability();
      if(searchInput) {
        searchInput.focus();
      }
      return;
    }
    const zoneConfig = getCurrentZoneConfig();

    if(!zoneConfig) {
      resultDiv.innerText = 'لا يوجد نظام إسقاط صالح متاح. الرجاء اختيار مدينة مرتبطة بمنطقة معتمدة.';
      setSingleResultCopyAvailability();
      return;
    }

    const zoneLabel = getZoneDisplayLabel(currentZoneKey) || 'Zone I';

    if(type === "latlong-to-Merchich") {
      const latDeg = parseFloat(document.getElementById('latDeg').value);
      const latMin = parseFloat(document.getElementById('latMin').value);
      const latSec = readSecondsValue('latSec');
      const lonDeg = parseFloat(document.getElementById('lonDeg').value);
      const lonMin = parseFloat(document.getElementById('lonMin').value);
      const lonSec = readSecondsValue('lonSec');
      const latHem = document.getElementById('latHemisphere').value;
      const lonHem = document.getElementById('lonHemisphere').value;

      const latitude = dmsToDecimal(latDeg, latMin, latSec, latHem);
      const longitude = dmsToDecimal(lonDeg, lonMin, lonSec, lonHem);

      if(isNaN(latitude) || isNaN(longitude)) {
        resultDiv.innerText = "Veuillez saisir des degrés, minutes et secondes valides pour la latitude et la longitude.";
        setSingleResultCopyAvailability();
        return;
      }

      const [xMerchich, yMerchich] = proj4(wgs84, zoneConfig.proj, [longitude, latitude]);
      const xInt = Math.round(xMerchich);
      const yInt = Math.round(yMerchich);
      resultDiv.innerText = `X = ${xInt}\nY = ${yInt}\nZone: ${zoneLabel}`;
      setSingleResultCopyAvailability();
      const latDmsText = formatDMS(decimalToDMS(latitude, true));
      const lonDmsText = formatDMS(decimalToDMS(longitude, false));
      updateConversionMarker(latitude, longitude, `الموقع الأصلي<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
    } else {
      const xInput = parseFloat(document.getElementById('manualX').value);
      const yInput = parseFloat(document.getElementById('manualY').value);

      if(isNaN(xInput) || isNaN(yInput)) {
        resultDiv.innerText = "Veuillez saisir des valeurs numériques valides pour X et Y.";
        setSingleResultCopyAvailability();
        return;
      }

      const [lon, lat] = proj4(zoneConfig.proj, wgs84, [xInput, yInput]);
      const latDms = decimalToDMS(lat, true);
      const lonDms = decimalToDMS(lon, false);
      const latDmsText = formatDMS(latDms);
      const lonDmsText = formatDMS(lonDms);
      resultDiv.innerText = `Latitude : ${latDmsText}\nLongitude : ${lonDmsText}\nZone: ${zoneLabel}`;
      setSingleResultCopyAvailability();
      updateConversionMarker(lat, lon, `النقطة المحوّلة إلى Lat/Long<br>${wrapDmsHtml(latDmsText, lonDmsText)}`);
    }
  }

  function downloadConvertedFile() {
    if(!lastConvertedRows.length) {
      alert('لا توجد نتائج متاحة للتحميل. الرجاء تنفيذ تحويل CSV أولاً.');
      return;
    }

    const unparseInput = lastConvertedFields ? { fields: lastConvertedFields, data: lastConvertedRows } : lastConvertedRows;
    const csvContent = Papa.unparse(unparseInput);
    const bom = '\ufeff';
    const blob = new Blob([bom, csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const prefix = lastConversionType === 'latlong-to-Merchich' ? 'Merchich' : 'latlong';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `${prefix}-converted-${timestamp}.csv`;

    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  const citySearchInputElement = document.getElementById('citySearchInput');
  if(citySearchInputElement) {
    citySearchInputElement.addEventListener('beforeinput', handleCitySearchBeforeInput);
    citySearchInputElement.addEventListener('input', handleCitySearchInput);
    citySearchInputElement.addEventListener('focus', handleCitySearchFocus);
    citySearchInputElement.addEventListener('keydown', handleCitySearchKeyDown);
    citySearchInputElement.addEventListener('blur', handleCitySearchBlur);
  }
  const citySuggestionsListElement = document.getElementById('citySuggestionsList');
  if(citySuggestionsListElement) {
    citySuggestionsListElement.addEventListener('click', handleCitySuggestionClick);
  }
  document.addEventListener('click', handleOutsideCitySuggestionClick);
  const conversionTypeElement = document.getElementById('conversionType');
  if(conversionTypeElement) {
    conversionTypeElement.addEventListener('change', () => {
      updateFileHint();
      validateAllCoordinateGroups();
    });
  }
  const csvInputElement = document.getElementById('csvFile');
  if(csvInputElement) {
    csvInputElement.addEventListener('change', handleCsvFileChange);
  }
  window.addEventListener('beforeunload', stopGeoWatch);
  initDmsValidationListeners();
  initManualNumericFields();
  initMap();
  initCityPicker();
  updateFileHint();
  updateConvertButtonState();
  validateAllCoordinateGroups();
  setSingleResultCopyAvailability();
</script>

</body>
</html>
